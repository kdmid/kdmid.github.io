{"meta":{"title":"hello","subtitle":"","description":"","author":"Deukjung","url":"https://kdmid.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"Home_Credit_Default_Risk","date":"2020-11-05T07:00:20.000Z","updated":"2020-11-05T07:05:57.958Z","comments":true,"path":"2020/11/05/Home_Credit_Default_Risk/","link":"","permalink":"https://kdmid.github.io/2020/11/05/Home_Credit_Default_Risk/","excerpt":"","text":"I. 데이터 불러오기1.1. Kaggle API 설치 Google Colab에서 Kaggle API를 불러오려면 다음 소스코드를 실행한다. 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.6/dist-packages (1.5.9) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.8.1) Requirement already satisfied: slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (0.0.1) Requirement already satisfied: urllib3 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: python-slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.0.1) Requirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from kaggle) (2020.6.20) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.41.1) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.6/dist-packages (from python-slugify-&gt;kaggle) (1.3) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (3.0.4) 1.2. Kaggle Token 다운로드 Kaggle에서 API Token을 다운로드 받는다. [Kaggle]-[My Account]-[API]-[Create New API Token]을 누르면 kaggle.json 파일이 다운로드 된다. 이 파일을 바탕화면에 옮긴 뒤, 아래 코드를 실행 시킨다. 12345678from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print(&#x27;uploaded file &quot;&#123;name&#125;&quot; with length &#123;length&#125; bytes&#x27;.format( name=fn, length=len(uploaded[fn]))) # kaggle.json을 아래 폴더로 옮긴 뒤, file을 사용할 수 있도록 권한을 부여한다. !mkdir -p ~/.kaggle/ &amp;&amp; mv kaggle.json ~/.kaggle/ &amp;&amp; chmod 600 ~/.kaggle/kaggle.json Upload widget is only available when the cell has been executed in the current browser session. Please rerun this cell to enable. Saving kaggle.json to kaggle.json uploaded file &quot;kaggle.json&quot; with length 67 bytes 1ls -1ha ~/.kaggle/kaggle.json /root/.kaggle/kaggle.json 에러 메시지가 없으면 성공적으로 json 파일이 업로드 되었다는 뜻이다. 1.3. Kaggle 데이터 불러오기 먼저 kaggle competition list를 불러온다. 1!kaggle competitions list Warning: Looks like you&#39;re using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) ref deadline category reward teamCount userHasEntered --------------------------------------------- ------------------- --------------- --------- --------- -------------- contradictory-my-dear-watson 2030-07-01 23:59:00 Getting Started Prizes 134 False gan-getting-started 2030-07-01 23:59:00 Getting Started Prizes 161 False tpu-getting-started 2030-06-03 23:59:00 Getting Started Knowledge 292 False digit-recognizer 2030-01-01 00:00:00 Getting Started Knowledge 2248 False titanic 2030-01-01 00:00:00 Getting Started Knowledge 17286 True house-prices-advanced-regression-techniques 2030-01-01 00:00:00 Getting Started Knowledge 4335 True connectx 2030-01-01 00:00:00 Getting Started Knowledge 367 False nlp-getting-started 2030-01-01 00:00:00 Getting Started Knowledge 1133 False rock-paper-scissors 2021-02-01 23:59:00 Playground Prizes 236 False riiid-test-answer-prediction 2021-01-07 23:59:00 Featured $100,000 1493 False nfl-big-data-bowl-2021 2021-01-05 23:59:00 Analytics $100,000 0 False competitive-data-science-predict-future-sales 2020-12-31 23:59:00 Playground Kudos 9393 False halite-iv-playground-edition 2020-12-31 23:59:00 Playground Knowledge 44 False predict-volcanic-eruptions-ingv-oe 2020-12-28 23:59:00 Playground Swag 200 False hashcode-drone-delivery 2020-12-14 23:59:00 Playground Knowledge 80 False cdp-unlocking-climate-solutions 2020-12-02 23:59:00 Analytics $91,000 0 False lish-moa 2020-11-30 23:59:00 Research $30,000 3468 False google-football 2020-11-30 23:59:00 Featured $6,000 925 False conways-reverse-game-of-life-2020 2020-11-30 23:59:00 Playground Swag 133 False lyft-motion-prediction-autonomous-vehicles 2020-11-25 23:59:00 Featured $30,000 789 False 여기에서 참여하기 원하는 대회의 데이터셋을 불러오면 된다. !kaggle competitions download -c + 대회명 (위의 목록 중 찾아서 복사 붙여넣기하기) 1!kaggle competitions download -c home-credit-default-risk Warning: Looks like you&#39;re using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) Downloading application_train.csv.zip to /content 47% 17.0M/36.1M [00:00&lt;00:00, 20.3MB/s] 100% 36.1M/36.1M [00:00&lt;00:00, 41.3MB/s] Downloading POS_CASH_balance.csv.zip to /content 89% 97.0M/109M [00:02&lt;00:00, 26.8MB/s] 100% 109M/109M [00:03&lt;00:00, 37.6MB/s] Downloading application_test.csv.zip to /content 86% 5.00M/5.81M [00:00&lt;00:00, 22.8MB/s] 100% 5.81M/5.81M [00:00&lt;00:00, 23.0MB/s] Downloading previous_application.csv.zip to /content 85% 65.0M/76.3M [00:01&lt;00:00, 33.2MB/s] 100% 76.3M/76.3M [00:01&lt;00:00, 46.5MB/s] Downloading bureau_balance.csv.zip to /content 86% 49.0M/56.8M [00:02&lt;00:00, 17.8MB/s] 100% 56.8M/56.8M [00:02&lt;00:00, 25.0MB/s] Downloading bureau.csv.zip to /content 82% 30.0M/36.8M [00:01&lt;00:00, 7.81MB/s] 100% 36.8M/36.8M [00:01&lt;00:00, 29.2MB/s] Downloading HomeCredit_columns_description.csv to /content 0% 0.00/36.5k [00:00&lt;?, ?B/s] 100% 36.5k/36.5k [00:00&lt;00:00, 29.2MB/s] Downloading installments_payments.csv.zip to /content 98% 265M/271M [00:07&lt;00:00, 36.7MB/s] 100% 271M/271M [00:07&lt;00:00, 39.1MB/s] Downloading sample_submission.csv to /content 0% 0.00/524k [00:00&lt;?, ?B/s] 100% 524k/524k [00:00&lt;00:00, 167MB/s] Downloading credit_card_balance.csv.zip to /content 84% 81.0M/96.7M [00:02&lt;00:00, 27.2MB/s] 100% 96.7M/96.7M [00:02&lt;00:00, 41.1MB/s] 데이터 압축 풀기 12345678! unzip application_test.csv.zip! unzip application_train.csv.zip! unzip bureau_balance.csv.zip! unzip bureau.csv.zip! unzip credit_card_balance.csv.zip! unzip installments_payments.csv.zip! unzip POS_CASH_balance.csv.zip! unzip previous_application.csv.zip Archive: application_test.csv.zip inflating: application_test.csv Archive: application_train.csv.zip inflating: application_train.csv Archive: bureau_balance.csv.zip inflating: bureau_balance.csv Archive: bureau.csv.zip inflating: bureau.csv Archive: credit_card_balance.csv.zip inflating: credit_card_balance.csv Archive: installments_payments.csv.zip inflating: installments_payments.csv Archive: POS_CASH_balance.csv.zip inflating: POS_CASH_balance.csv Archive: previous_application.csv.zip inflating: previous_application.csv 1!ls application_test.csv HomeCredit_columns_description.csv application_test.csv.zip installments_payments.csv application_train.csv installments_payments.csv.zip application_train.csv.zip POS_CASH_balance.csv bureau_balance.csv POS_CASH_balance.csv.zip bureau_balance.csv.zip previous_application.csv bureau.csv previous_application.csv.zip bureau.csv.zip sample_data credit_card_balance.csv sample_submission.csv credit_card_balance.csv.zip II. 데이터 확인 이 데이터는 은행을 이용하지 않은 사람들에게 신용대출(대출)을 제공하는 서비스인 Home Credit에서 제공된다. 고객이 대출금을 상환가능 여부를 예측하는 것은 매우 중요하다. Supervised: label은 교육 데이터에 포함되며, 목적은 feature로부터 label을 예측하는 방법을 학습하는 모델을 훈련시키는 것이다. Classification: 0(대출금을 제 때 상환할 수 있음), 1(대출금 상환에 어려움이 있음) application_train/application_test: Home Credit에서 대출 신청에 대한 정보가 포함된 주요 교육 및 테스트 데이터 bureau: 다른 금융 기관에서 고객의 과거 신용에 관한 데이터 bureau_balance: 과거 신용에 대한 월별 데이터 POS_CASH_BANCE: Home Credit이 가지고 있는 고객의 이전 판매 시점 또는 현금 대출에 대한 월별 데이터 credit_card_balance: Home Credit에서 고객이 가지고 있던 이전 신용 카드에 대한 월별 데이터 installments_payment: Home Credit의 이전 대출에 대한 지급 내역 2.1. 패키지를 설치1234567891011121314151617# numpy and pandas for data manipulationimport numpy as npimport pandas as pd # sklearn preprocessing for dealing with categorical variablesfrom sklearn.preprocessing import LabelEncoder# File system manangementimport os# Suppress warnings import warningswarnings.filterwarnings(&#x27;ignore&#x27;)# matplotlib and seaborn for plottingimport matplotlib.pyplot as pltimport seaborn as sns 2.2. 데이터 확인12# List files availableprint(os.listdir()) [&#39;.config&#39;, &#39;previous_application.csv&#39;, &#39;application_train.csv&#39;, &#39;bureau_balance.csv&#39;, &#39;application_test.csv.zip&#39;, &#39;bureau.csv&#39;, &#39;POS_CASH_balance.csv&#39;, &#39;previous_application.csv.zip&#39;, &#39;bureau_balance.csv.zip&#39;, &#39;POS_CASH_balance.csv.zip&#39;, &#39;HomeCredit_columns_description.csv&#39;, &#39;bureau.csv.zip&#39;, &#39;installments_payments.csv.zip&#39;, &#39;sample_submission.csv&#39;, &#39;installments_payments.csv&#39;, &#39;application_train.csv.zip&#39;, &#39;credit_card_balance.csv&#39;, &#39;application_test.csv&#39;, &#39;credit_card_balance.csv.zip&#39;, &#39;sample_data&#39;] 1234# Training dataapp_train = pd.read_csv(&#x27;application_train.csv&#x27;)print(&#x27;Training data shape: &#x27;, app_train.shape)app_train.head() Training data shape: (307511, 122) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; SK_ID_CURR TARGET NAME_CONTRACT_TYPE CODE_GENDER FLAG_OWN_CAR FLAG_OWN_REALTY CNT_CHILDREN AMT_INCOME_TOTAL AMT_CREDIT AMT_ANNUITY AMT_GOODS_PRICE NAME_TYPE_SUITE NAME_INCOME_TYPE NAME_EDUCATION_TYPE NAME_FAMILY_STATUS NAME_HOUSING_TYPE REGION_POPULATION_RELATIVE DAYS_BIRTH DAYS_EMPLOYED DAYS_REGISTRATION DAYS_ID_PUBLISH OWN_CAR_AGE FLAG_MOBIL FLAG_EMP_PHONE FLAG_WORK_PHONE FLAG_CONT_MOBILE FLAG_PHONE FLAG_EMAIL OCCUPATION_TYPE CNT_FAM_MEMBERS REGION_RATING_CLIENT REGION_RATING_CLIENT_W_CITY WEEKDAY_APPR_PROCESS_START HOUR_APPR_PROCESS_START REG_REGION_NOT_LIVE_REGION REG_REGION_NOT_WORK_REGION LIVE_REGION_NOT_WORK_REGION REG_CITY_NOT_LIVE_CITY REG_CITY_NOT_WORK_CITY LIVE_CITY_NOT_WORK_CITY ... LIVINGAPARTMENTS_MEDI LIVINGAREA_MEDI NONLIVINGAPARTMENTS_MEDI NONLIVINGAREA_MEDI FONDKAPREMONT_MODE HOUSETYPE_MODE TOTALAREA_MODE WALLSMATERIAL_MODE EMERGENCYSTATE_MODE OBS_30_CNT_SOCIAL_CIRCLE DEF_30_CNT_SOCIAL_CIRCLE OBS_60_CNT_SOCIAL_CIRCLE DEF_60_CNT_SOCIAL_CIRCLE DAYS_LAST_PHONE_CHANGE FLAG_DOCUMENT_2 FLAG_DOCUMENT_3 FLAG_DOCUMENT_4 FLAG_DOCUMENT_5 FLAG_DOCUMENT_6 FLAG_DOCUMENT_7 FLAG_DOCUMENT_8 FLAG_DOCUMENT_9 FLAG_DOCUMENT_10 FLAG_DOCUMENT_11 FLAG_DOCUMENT_12 FLAG_DOCUMENT_13 FLAG_DOCUMENT_14 FLAG_DOCUMENT_15 FLAG_DOCUMENT_16 FLAG_DOCUMENT_17 FLAG_DOCUMENT_18 FLAG_DOCUMENT_19 FLAG_DOCUMENT_20 FLAG_DOCUMENT_21 AMT_REQ_CREDIT_BUREAU_HOUR AMT_REQ_CREDIT_BUREAU_DAY AMT_REQ_CREDIT_BUREAU_WEEK AMT_REQ_CREDIT_BUREAU_MON AMT_REQ_CREDIT_BUREAU_QRT AMT_REQ_CREDIT_BUREAU_YEAR 0 100002 1 Cash loans M N Y 0 202500.0 406597.5 24700.5 351000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.018801 -9461 -637 -3648.0 -2120 NaN 1 1 0 1 1 0 Laborers 1.0 2 2 WEDNESDAY 10 0 0 0 0 0 0 ... 0.0205 0.0193 0.0000 0.00 reg oper account block of flats 0.0149 Stone, brick No 2.0 2.0 2.0 2.0 -1134.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 1.0 1 100003 0 Cash loans F N N 0 270000.0 1293502.5 35698.5 1129500.0 Family State servant Higher education Married House / apartment 0.003541 -16765 -1188 -1186.0 -291 NaN 1 1 0 1 1 0 Core staff 2.0 1 1 MONDAY 11 0 0 0 0 0 0 ... 0.0787 0.0558 0.0039 0.01 reg oper account block of flats 0.0714 Block No 1.0 0.0 1.0 0.0 -828.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 2 100004 0 Revolving loans M Y Y 0 67500.0 135000.0 6750.0 135000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.010032 -19046 -225 -4260.0 -2531 26.0 1 1 1 1 1 0 Laborers 1.0 2 2 MONDAY 9 0 0 0 0 0 0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -815.0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 3 100006 0 Cash loans F N Y 0 135000.0 312682.5 29686.5 297000.0 Unaccompanied Working Secondary / secondary special Civil marriage House / apartment 0.008019 -19005 -3039 -9833.0 -2437 NaN 1 1 0 1 0 0 Laborers 2.0 2 2 WEDNESDAY 17 0 0 0 0 0 0 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 2.0 0.0 2.0 0.0 -617.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 NaN NaN NaN NaN NaN NaN 4 100007 0 Cash loans M N Y 0 121500.0 513000.0 21865.5 513000.0 Unaccompanied Working Secondary / secondary special Single / not married House / apartment 0.028663 -19932 -3038 -4311.0 -3458 NaN 1 1 0 1 0 0 Core staff 1.0 2 2 THURSDAY 11 0 0 0 0 1 1 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -1106.0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 5 rows × 122 columns 1234# Testing data featuresapp_test = pd.read_csv(&#x27;application_test.csv&#x27;)print(&#x27;Testing data shape: &#x27;, app_test.shape)app_test.head() Testing data shape: (48744, 121) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; SK_ID_CURR NAME_CONTRACT_TYPE CODE_GENDER FLAG_OWN_CAR FLAG_OWN_REALTY CNT_CHILDREN AMT_INCOME_TOTAL AMT_CREDIT AMT_ANNUITY AMT_GOODS_PRICE NAME_TYPE_SUITE NAME_INCOME_TYPE NAME_EDUCATION_TYPE NAME_FAMILY_STATUS NAME_HOUSING_TYPE REGION_POPULATION_RELATIVE DAYS_BIRTH DAYS_EMPLOYED DAYS_REGISTRATION DAYS_ID_PUBLISH OWN_CAR_AGE FLAG_MOBIL FLAG_EMP_PHONE FLAG_WORK_PHONE FLAG_CONT_MOBILE FLAG_PHONE FLAG_EMAIL OCCUPATION_TYPE CNT_FAM_MEMBERS REGION_RATING_CLIENT REGION_RATING_CLIENT_W_CITY WEEKDAY_APPR_PROCESS_START HOUR_APPR_PROCESS_START REG_REGION_NOT_LIVE_REGION REG_REGION_NOT_WORK_REGION LIVE_REGION_NOT_WORK_REGION REG_CITY_NOT_LIVE_CITY REG_CITY_NOT_WORK_CITY LIVE_CITY_NOT_WORK_CITY ORGANIZATION_TYPE ... LIVINGAPARTMENTS_MEDI LIVINGAREA_MEDI NONLIVINGAPARTMENTS_MEDI NONLIVINGAREA_MEDI FONDKAPREMONT_MODE HOUSETYPE_MODE TOTALAREA_MODE WALLSMATERIAL_MODE EMERGENCYSTATE_MODE OBS_30_CNT_SOCIAL_CIRCLE DEF_30_CNT_SOCIAL_CIRCLE OBS_60_CNT_SOCIAL_CIRCLE DEF_60_CNT_SOCIAL_CIRCLE DAYS_LAST_PHONE_CHANGE FLAG_DOCUMENT_2 FLAG_DOCUMENT_3 FLAG_DOCUMENT_4 FLAG_DOCUMENT_5 FLAG_DOCUMENT_6 FLAG_DOCUMENT_7 FLAG_DOCUMENT_8 FLAG_DOCUMENT_9 FLAG_DOCUMENT_10 FLAG_DOCUMENT_11 FLAG_DOCUMENT_12 FLAG_DOCUMENT_13 FLAG_DOCUMENT_14 FLAG_DOCUMENT_15 FLAG_DOCUMENT_16 FLAG_DOCUMENT_17 FLAG_DOCUMENT_18 FLAG_DOCUMENT_19 FLAG_DOCUMENT_20 FLAG_DOCUMENT_21 AMT_REQ_CREDIT_BUREAU_HOUR AMT_REQ_CREDIT_BUREAU_DAY AMT_REQ_CREDIT_BUREAU_WEEK AMT_REQ_CREDIT_BUREAU_MON AMT_REQ_CREDIT_BUREAU_QRT AMT_REQ_CREDIT_BUREAU_YEAR 0 100001 Cash loans F N Y 0 135000.0 568800.0 20560.5 450000.0 Unaccompanied Working Higher education Married House / apartment 0.018850 -19241 -2329 -5170.0 -812 NaN 1 1 0 1 0 1 NaN 2.0 2 2 TUESDAY 18 0 0 0 0 0 0 Kindergarten ... NaN 0.0514 NaN NaN NaN block of flats 0.0392 Stone, brick No 0.0 0.0 0.0 0.0 -1740.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 1 100005 Cash loans M N Y 0 99000.0 222768.0 17370.0 180000.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.035792 -18064 -4469 -9118.0 -1623 NaN 1 1 0 1 0 0 Low-skill Laborers 2.0 2 2 FRIDAY 9 0 0 0 0 0 0 Self-employed ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 0.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 3.0 2 100013 Cash loans M Y Y 0 202500.0 663264.0 69777.0 630000.0 NaN Working Higher education Married House / apartment 0.019101 -20038 -4458 -2175.0 -3503 5.0 1 1 0 1 0 0 Drivers 2.0 2 2 MONDAY 14 0 0 0 0 0 0 Transport: type 3 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -856.0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 1.0 4.0 3 100028 Cash loans F N Y 2 315000.0 1575000.0 49018.5 1575000.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.026392 -13976 -1866 -2000.0 -4208 NaN 1 1 0 1 1 0 Sales staff 4.0 2 2 WEDNESDAY 11 0 0 0 0 0 0 Business Entity Type 3 ... 0.2446 0.3739 0.0388 0.0817 reg oper account block of flats 0.3700 Panel No 0.0 0.0 0.0 0.0 -1805.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.0 0.0 0.0 0.0 0.0 3.0 4 100038 Cash loans M Y N 1 180000.0 625500.0 32067.0 625500.0 Unaccompanied Working Secondary / secondary special Married House / apartment 0.010032 -13040 -2191 -4000.0 -4262 16.0 1 1 1 1 0 0 NaN 3.0 2 2 FRIDAY 5 0 0 0 0 1 1 Business Entity Type 3 ... NaN NaN NaN NaN NaN NaN NaN NaN NaN 0.0 0.0 0.0 0.0 -821.0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 NaN NaN NaN NaN NaN NaN 5 rows × 121 columns III. 데이터 분석 EDA(Exploratory Data Analysis)Examine the Distribution of the Target Column Target은 우리가 예측하는 것을 묻는 것이다. 0(대출금을 제 때 상환할 수 있음), 1(대출금 상환에 어려움이 있음) 우리는 우선 각 범주에 속하는 대출의 수를 조사할 수 있다. 1app_train[&#x27;TARGET&#x27;].value_counts() 0 282686 1 24825 Name: TARGET, dtype: int64 1app_train[&#x27;TARGET&#x27;].astype(int).plot.hist(); 여기서 데이터의 불균형함을 확인할 수 있다. 제때 갚지 못한 대출보다 제때 갚은 대출이 훨씬 많다. 이러한 불균형함을 보완하기 위해 나중에 무게감을 다르게 부여할 것이다. Examine Missing Values 각 행별로 결측값이 어느정도 있는지 확인해보자. 123456789101112131415161718192021222324252627# Function to calculate missing values by column# Funct def missing_values_table(df): # Total missing values mis_val = df.isnull().sum() # Percentage of missing values mis_val_percent = 100 * df.isnull().sum() / len(df) # Make a table with the results mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) # Rename the columns mis_val_table_ren_columns = mis_val_table.rename( columns = &#123;0 : &#x27;Missing Values&#x27;, 1 : &#x27;% of Total Values&#x27;&#125;) # Sort the table by percentage of missing descending mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( &#x27;% of Total Values&#x27;, ascending=False).round(1) # Print some summary information print (&quot;Your selected dataframe has &quot; + str(df.shape[1]) + &quot; columns.\\n&quot; &quot;There are &quot; + str(mis_val_table_ren_columns.shape[0]) + &quot; columns that have missing values.&quot;) # Return the dataframe with missing information return mis_val_table_ren_columns 123# Missing values statisticsmissing_values = missing_values_table(app_train)missing_values.head(20) Your selected dataframe has 122 columns. There are 67 columns that have missing values. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; Missing Values % of Total Values COMMONAREA_MEDI 214865 69.9 COMMONAREA_AVG 214865 69.9 COMMONAREA_MODE 214865 69.9 NONLIVINGAPARTMENTS_MEDI 213514 69.4 NONLIVINGAPARTMENTS_MODE 213514 69.4 NONLIVINGAPARTMENTS_AVG 213514 69.4 FONDKAPREMONT_MODE 210295 68.4 LIVINGAPARTMENTS_MODE 210199 68.4 LIVINGAPARTMENTS_MEDI 210199 68.4 LIVINGAPARTMENTS_AVG 210199 68.4 FLOORSMIN_MODE 208642 67.8 FLOORSMIN_MEDI 208642 67.8 FLOORSMIN_AVG 208642 67.8 YEARS_BUILD_MODE 204488 66.5 YEARS_BUILD_MEDI 204488 66.5 YEARS_BUILD_AVG 204488 66.5 OWN_CAR_AGE 202929 66.0 LANDAREA_AVG 182590 59.4 LANDAREA_MEDI 182590 59.4 LANDAREA_MODE 182590 59.4 머신러닝 모델이 구축할 때가 되면, 결측값들을 채워야 한다. 이후의 작업에서는 imputation 필요 없이 결측값을 처리할 수 있는 XGBoost 모델을 사용할 것이다. 또 다른 옵션은 결측값 비율이 높은 열을 필요 여부에 따라 삭제하는 것이다. Column Types int64과 float64은 숫자형 변수이다(이산형 또는 연속형). object행은 문자형이고 범주형 feature이다. 12# Number of each type of columnapp_train.dtypes.value_counts() float64 65 int64 41 object 16 dtype: int64 object(범주형) 열에 있는 고유한 항목 수를 살펴봅시다. 12# Number of unique classes in each object columnapp_train.select_dtypes(&#x27;object&#x27;).apply(pd.Series.nunique, axis = 0) NAME_CONTRACT_TYPE 2 CODE_GENDER 3 FLAG_OWN_CAR 2 FLAG_OWN_REALTY 2 NAME_TYPE_SUITE 7 NAME_INCOME_TYPE 8 NAME_EDUCATION_TYPE 5 NAME_FAMILY_STATUS 6 NAME_HOUSING_TYPE 6 OCCUPATION_TYPE 18 WEEKDAY_APPR_PROCESS_START 7 ORGANIZATION_TYPE 58 FONDKAPREMONT_MODE 4 HOUSETYPE_MODE 3 WALLSMATERIAL_MODE 7 EMERGENCYSTATE_MODE 2 dtype: int64 대부분의 범주형 값들의 항목 수는 매우 작기 때문에 대처할 방법이 필요하다. Encoding Categorical Variables 머신러닝 모델은 범주형 데이터를 다룰 수 없기 때문에 숫자로 변환할 필요가 있다. Label encoding 범주형 변수의 각 고유 범주에 정수를 할당한다. 카테고리에 임의의 순서를 부여한다는 점이 문제이다. 고유값이 두 개인 label 인코딩은 괜찮지만 두 개 이상의 고유한 범주에 대해서는 One-hot encoding이 더 좋다. One-hot encoding 범주형 변수의 각 고유 범주에 대해 새 열을 생성한다. 해당 범주에 대한 열에는 1을, 다른 모든 새 열에는 0을 부여한다. class가 많은 범주형 변수에서는 범주에 임의의 값을 부과하지 않기 때문에 가장 좋은 방법이라고 생각한다. 여기서 범주가 2개만 있는 범주형 변수에 Label encoding을 사용하고, 범주가 2개 이상의 범주형 변수에 대해 One-hot encoding을 사용할 것이다. Label Encoding and One-Hot Encoding Label encoding 경우 Scikit-Learn LabelEncoder를 사용하고, One-hot encoding의 경우 the pandas get_dummies(df) 기능을 사용한다 12345678910111213141516171819# Create a label encoder objectle = LabelEncoder()le_count = 0# Iterate through the columns 열 반복for col in app_train: if app_train[col].dtype == &#x27;object&#x27;: # If 2 or fewer unique categories if len(list(app_train[col].unique())) &lt;= 2: # Train on the training data le.fit(app_train[col]) # Transform both training and testing data app_train[col] = le.transform(app_train[col]) app_test[col] = le.transform(app_test[col]) # Keep track of how many columns were label encoded le_count += 1 print(&#x27;%d columns were label encoded.&#x27; % le_count) 3 columns were label encoded. 123456# one-hot encoding of categorical variablesapp_train = pd.get_dummies(app_train)app_test = pd.get_dummies(app_test)print(&#x27;Training Features shape: &#x27;, app_train.shape)print(&#x27;Testing Features shape: &#x27;, app_test.shape) Training Features shape: (307511, 243) Testing Features shape: (48744, 239) Aligning Training and Testing Data training data와 testing data의 공통된 feature(행)이 있어야 한다. One-hot encoding은 training data에서 더 많은 열을 생성했는데, 이는 testing data에 범주가 표시되지 않는 일부 범주형 변수가 있기 때문이다. testing data에 없는 training data 내의 열을 제거하려면 데이터프레임을 정렬해야 한다. training data에서 대상 열을 추출한다. 정렬을 수행할 때 행이 아닌 열에 따라 데이터 프레임을 정렬하도록 axis = 1을 설정해야 한다. 12345678910train_labels = app_train[&#x27;TARGET&#x27;]# Align the training and testing data, keep only columns present in both dataframesapp_train, app_test = app_train.align(app_test, join = &#x27;inner&#x27;, axis = 1)# Add the target back inapp_train[&#x27;TARGET&#x27;] = train_labelsprint(&#x27;Training Features shape: &#x27;, app_train.shape)print(&#x27;Testing Features shape: &#x27;, app_test.shape) Training Features shape: (307511, 240) Testing Features shape: (48744, 239) training dataset과 testing dataset은 머신러닝에서 필요한 동일한 feature을 가지게 되었다. One-hot encoding으로 인해 feature 수가 크게 늘었으므로, 데이터셋 크기를 줄이기 위해 관련없는 feature를 나중에 제거할 필요가 있다. Back to Exploratory Data AnalysisAnomalies 이상징후 EDA를 할 때, 데이터 내의 이상징후를 주의하여야 한다. 여기에는 잘못된 형식의 숫자, 측정 장비의 오류로 인한 극단적인 값들 있다. 이상 징후를 잡기 위해선 describe를 사용하여 열의 통계를 봐야한다. DAYS_BIRTH행의 값들은 최근 대출 신청에 상대적인 값을 갖기 때문에 음수로 표현된다. 통계치를 년 단위로 보려면 -1로 나누고 1년 내 일수(365일)로 나누면 된다. 1(app_train[&#x27;DAYS_BIRTH&#x27;] / -365).describe() count 307511.000000 mean 43.936973 std 11.956133 min 20.517808 25% 34.008219 50% 43.150685 75% 53.923288 max 69.120548 Name: DAYS_BIRTH, dtype: float64 나이에 있어서 이상한 값들은 보이지 않는다. 1app_train[&#x27;DAYS_EMPLOYED&#x27;].describe() count 307511.000000 mean 63815.045904 std 141275.766519 min -17912.000000 25% -2760.000000 50% -1213.000000 75% -289.000000 max 365243.000000 Name: DAYS_EMPLOYED, dtype: float64 값이 이상하다.(최댓값이 1000년 씩이다 된다) 12app_train[&#x27;DAYS_EMPLOYED&#x27;].plot.hist(title = &#x27;Days Employment Histogram&#x27;);plt.xlabel(&#x27;Days Employment&#x27;); 12345anom = app_train[app_train[&#x27;DAYS_EMPLOYED&#x27;] == 365243]non_anom = app_train[app_train[&#x27;DAYS_EMPLOYED&#x27;] != 365243]print(&#x27;The non-anomalies default on %0.2f%% of loans&#x27; % (100 * non_anom[&#x27;TARGET&#x27;].mean()))print(&#x27;The anomalies default on %0.2f%% of loans&#x27; % (100 * anom[&#x27;TARGET&#x27;].mean()))print(&#x27;There are %d anomalous days of employment&#x27; % len(anom)) The non-anomalies default on 8.66% of loans The anomalies default on 5.40% of loans There are 55374 anomalous days of employment 이상 징후는 채무불이행 비율이 낮은 것으로 확인된다. 이상한 값들을 처리하려면 결측값으로 바꾸거나 변측값으로 바꾸어야 한다. 12345678# Create an anomalous flag columnapp_train[&#x27;DAYS_EMPLOYED_ANOM&#x27;] = app_train[&quot;DAYS_EMPLOYED&quot;] == 365243# Replace the anomalous values with nanapp_train[&#x27;DAYS_EMPLOYED&#x27;].replace(&#123;365243: np.nan&#125;, inplace = True)app_train[&#x27;DAYS_EMPLOYED&#x27;].plot.hist(title = &#x27;Days Employment Histogram&#x27;);plt.xlabel(&#x27;Days Employment&#x27;); 1234app_test[&#x27;DAYS_EMPLOYED_ANOM&#x27;] = app_test[&quot;DAYS_EMPLOYED&quot;] == 365243app_test[&quot;DAYS_EMPLOYED&quot;].replace(&#123;365243: np.nan&#125;, inplace = True)print(&#x27;There are %d anomalies in the test data out of %d entries&#x27; % (app_test[&quot;DAYS_EMPLOYED_ANOM&quot;].sum(), len(app_test))) There are 9274 anomalies in the test data out of 48744 entries Correlations123456# Find correlations with the target and sortcorrelations = app_train.corr()[&#x27;TARGET&#x27;].sort_values()# Display correlationsprint(&#x27;Most Positive Correlations:\\n&#x27;, correlations.tail(15))print(&#x27;\\nMost Negative Correlations:\\n&#x27;, correlations.head(15)) Most Positive Correlations: OCCUPATION_TYPE_Laborers 0.043019 FLAG_DOCUMENT_3 0.044346 REG_CITY_NOT_LIVE_CITY 0.044395 FLAG_EMP_PHONE 0.045982 NAME_EDUCATION_TYPE_Secondary / secondary special 0.049824 REG_CITY_NOT_WORK_CITY 0.050994 DAYS_ID_PUBLISH 0.051457 CODE_GENDER_M 0.054713 DAYS_LAST_PHONE_CHANGE 0.055218 NAME_INCOME_TYPE_Working 0.057481 REGION_RATING_CLIENT 0.058899 REGION_RATING_CLIENT_W_CITY 0.060893 DAYS_EMPLOYED 0.074958 DAYS_BIRTH 0.078239 TARGET 1.000000 Name: TARGET, dtype: float64 Most Negative Correlations: EXT_SOURCE_3 -0.178919 EXT_SOURCE_2 -0.160472 EXT_SOURCE_1 -0.155317 NAME_EDUCATION_TYPE_Higher education -0.056593 CODE_GENDER_F -0.054704 NAME_INCOME_TYPE_Pensioner -0.046209 DAYS_EMPLOYED_ANOM -0.045987 ORGANIZATION_TYPE_XNA -0.045987 FLOORSMAX_AVG -0.044003 FLOORSMAX_MEDI -0.043768 FLOORSMAX_MODE -0.043226 EMERGENCYSTATE_MODE_No -0.042201 HOUSETYPE_MODE_block of flats -0.040594 AMT_GOODS_PRICE -0.039645 REGION_POPULATION_RELATIVE -0.037227 Name: TARGET, dtype: float64 Effect of Age on Repayment123# Find the correlation of the positive days since birth and targetapp_train[&#x27;DAYS_BIRTH&#x27;] = abs(app_train[&#x27;DAYS_BIRTH&#x27;])app_train[&#x27;DAYS_BIRTH&#x27;].corr(app_train[&#x27;TARGET&#x27;]) -0.07823930830982694 고객이 나이가 많을수록 대출금을 제때 상환하는 경향이 있다. 123456# Set the style of plotsplt.style.use(&#x27;fivethirtyeight&#x27;)# Plot the distribution of ages in yearsplt.hist(app_train[&#x27;DAYS_BIRTH&#x27;] / 365, edgecolor = &#x27;k&#x27;, bins = 25)plt.title(&#x27;Age of Client&#x27;); plt.xlabel(&#x27;Age (years)&#x27;); plt.ylabel(&#x27;Count&#x27;); 특이점이 없다는 것을 확인할 수 있다. 연령대가 대상에 미치는 영향을 시각화하기 위해 kernel density estimation plot (KDE) 만들어보자. 12345678910plt.figure(figsize = (10, 8))# KDE plot of loans that were repaid on timesns.kdeplot(app_train.loc[app_train[&#x27;TARGET&#x27;] == 0, &#x27;DAYS_BIRTH&#x27;] / 365, label = &#x27;target == 0&#x27;)# KDE plot of loans which were not repaid on timesns.kdeplot(app_train.loc[app_train[&#x27;TARGET&#x27;] == 1, &#x27;DAYS_BIRTH&#x27;] / 365, label = &#x27;target == 1&#x27;)# Labeling of plotplt.xlabel(&#x27;Age (years)&#x27;); plt.ylabel(&#x27;Density&#x27;); plt.title(&#x27;Distribution of Ages&#x27;); target == 1 커브가 나이가 젊어지는 쪽을 향해 기울어진다. 이는 유의미한 상관 계수(-0.07 상관 계수)는 아니지만, 이 변수는 대상에 영향을 미치기 때문에 머신러닝 모델에서 유용할 것으로 보인다. 1234567# Age information into a separate dataframeage_data = app_train[[&#x27;TARGET&#x27;, &#x27;DAYS_BIRTH&#x27;]]age_data[&#x27;YEARS_BIRTH&#x27;] = age_data[&#x27;DAYS_BIRTH&#x27;] / 365# Bin the age dataage_data[&#x27;YEARS_BINNED&#x27;] = pd.cut(age_data[&#x27;YEARS_BIRTH&#x27;], bins = np.linspace(20, 70, num = 11))age_data.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; TARGET DAYS_BIRTH YEARS_BIRTH YEARS_BINNED 0 1 9461 25.920548 (25.0, 30.0] 1 0 16765 45.931507 (45.0, 50.0] 2 0 19046 52.180822 (50.0, 55.0] 3 0 19005 52.068493 (50.0, 55.0] 4 0 19932 54.608219 (50.0, 55.0] 5 0 16941 46.413699 (45.0, 50.0] 6 0 13778 37.747945 (35.0, 40.0] 7 0 18850 51.643836 (50.0, 55.0] 8 0 20099 55.065753 (55.0, 60.0] 9 0 14469 39.641096 (35.0, 40.0] 123# Group by the bin and calculate averagesage_groups = age_data.groupby(&#x27;YEARS_BINNED&#x27;).mean()age_groups .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; TARGET DAYS_BIRTH YEARS_BIRTH YEARS_BINNED (20.0, 25.0] 0.123036 8532.795625 23.377522 (25.0, 30.0] 0.111436 10155.219250 27.822518 (30.0, 35.0] 0.102814 11854.848377 32.479037 (35.0, 40.0] 0.089414 13707.908253 37.555913 (40.0, 45.0] 0.078491 15497.661233 42.459346 (45.0, 50.0] 0.074171 17323.900441 47.462741 (50.0, 55.0] 0.066968 19196.494791 52.593136 (55.0, 60.0] 0.055314 20984.262742 57.491131 (60.0, 65.0] 0.052737 22780.547460 62.412459 (65.0, 70.0] 0.037270 24292.614340 66.555108 12345678plt.figure(figsize = (8, 8))# Graph the age bins and the average of the target as a bar plotplt.bar(age_groups.index.astype(str), 100 * age_groups[&#x27;TARGET&#x27;])# Plot labelingplt.xticks(rotation = 75); plt.xlabel(&#x27;Age Group (years)&#x27;); plt.ylabel(&#x27;Failure to Repay (%)&#x27;)plt.title(&#x27;Failure to Repay by Age Group&#x27;); 분명한 경향성을 보이는 것을 확인할 수 있다. 젊은 지원자들은 대출금을 상환하지 않을 가능성이 더 높은 것을 확인할 수 있다. 상환불능률은 나이가 어린 3개의 연령층이 10%를 넘고, 최고령 연령층은 5%를 넘지 않는다. 이는 젊은 고객들은 대출금을 상환할 가능성이 적기 때문에, 은행이 젊은 고객들에게 더 많은 안내나 재정 계획 팁을 제공해야 하며, 제시간에 지불할 수 있도록 예방 조치를 취하는 것이 현명할 것이다. Exterior Sources 목표값과 가장 밀접한 음의 상관관계를 갖는 3가지 변수는 EXT_SOURCE_1, EXT_SOURCE_2, EXT_SOURCE_3이다. 이는 “외부 데이터 소스의 정규화된 점수”를 나타낸다. EXT_SOURCE과 target 각각의 상관관계를 보여준다. 1234# Extract the EXT_SOURCE variables and show correlationsext_data = app_train[[&#x27;TARGET&#x27;, &#x27;EXT_SOURCE_1&#x27;, &#x27;EXT_SOURCE_2&#x27;, &#x27;EXT_SOURCE_3&#x27;, &#x27;DAYS_BIRTH&#x27;]]ext_data_corrs = ext_data.corr()ext_data_corrs .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; TARGET EXT_SOURCE_1 EXT_SOURCE_2 EXT_SOURCE_3 DAYS_BIRTH TARGET 1.000000 -0.155317 -0.160472 -0.178919 -0.078239 EXT_SOURCE_1 -0.155317 1.000000 0.213982 0.186846 0.600610 EXT_SOURCE_2 -0.160472 0.213982 1.000000 0.109167 0.091996 EXT_SOURCE_3 -0.178919 0.186846 0.109167 1.000000 0.205478 DAYS_BIRTH -0.078239 0.600610 0.091996 0.205478 1.000000 12345plt.figure(figsize = (8, 6))# Heatmap of correlationssns.heatmap(ext_data_corrs, cmap = plt.cm.RdYlBu_r, vmin = -0.25, annot = True, vmax = 0.6)plt.title(&#x27;Correlation Heatmap&#x27;); EXT_SOURCE 기능은 모두 target과 음의 상관관계를 가지고 있어 EXT_SOURCE의 가치가 증가할수록 고객이 대출금을 상환할 가능성이 더 높은 것을 알 수 있다. DAYS_BOYT가 EXT_SOURCE_1와 양의 상관관계가 있다는 것을 알 수 있다. 다음으로 대상의 값에 의해 색칠된 형상의 분포를 살펴볼 수 있다. 1234567891011121314151617plt.figure(figsize = (10, 12))# iterate through the sourcesfor i, source in enumerate([&#x27;EXT_SOURCE_1&#x27;, &#x27;EXT_SOURCE_2&#x27;, &#x27;EXT_SOURCE_3&#x27;]): # create a new subplot for each source plt.subplot(3, 1, i + 1) # plot repaid loans sns.kdeplot(app_train.loc[app_train[&#x27;TARGET&#x27;] == 0, source], label = &#x27;target == 0&#x27;) # plot loans that were not repaid sns.kdeplot(app_train.loc[app_train[&#x27;TARGET&#x27;] == 1, source], label = &#x27;target == 1&#x27;) # Label the plots plt.title(&#x27;Distribution of %s by Target Value&#x27; % source) plt.xlabel(&#x27;%s&#x27; % source); plt.ylabel(&#x27;Density&#x27;); plt.tight_layout(h_pad = 2.5) EXT_SOURCE_3은 target 값과의 차이가 가장 크다 이 feature와 대출금을 상환할 가능성이 상관관계가 크진 않지만, 어느 정도 관계가 있다는 것을 분명히 알 수 있다..","categories":[],"tags":[]},{"title":"","slug":"Titanic_Practice_in_Colab_with_Kaggle","date":"2020-11-04T06:26:26.000Z","updated":"2020-11-05T06:28:34.036Z","comments":true,"path":"2020/11/04/Titanic_Practice_in_Colab_with_Kaggle/","link":"","permalink":"https://kdmid.github.io/2020/11/04/Titanic_Practice_in_Colab_with_Kaggle/","excerpt":"","text":"I. Kaggle 데이터 사용을 위한 사전 세팅1.1. Kaggle API 설치 Google Colab에서 Kaggle API를 불러오려면 다음 소스코드를 실행한다. 1!pip install kaggle Requirement already satisfied: kaggle in /usr/local/lib/python3.6/dist-packages (1.5.9) Requirement already satisfied: urllib3 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.24.3) Requirement already satisfied: python-slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.0.1) Requirement already satisfied: python-dateutil in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.8.1) Requirement already satisfied: requests in /usr/local/lib/python3.6/dist-packages (from kaggle) (2.23.0) Requirement already satisfied: six&gt;=1.10 in /usr/local/lib/python3.6/dist-packages (from kaggle) (1.15.0) Requirement already satisfied: certifi in /usr/local/lib/python3.6/dist-packages (from kaggle) (2020.6.20) Requirement already satisfied: tqdm in /usr/local/lib/python3.6/dist-packages (from kaggle) (4.41.1) Requirement already satisfied: slugify in /usr/local/lib/python3.6/dist-packages (from kaggle) (0.0.1) Requirement already satisfied: text-unidecode&gt;=1.3 in /usr/local/lib/python3.6/dist-packages (from python-slugify-&gt;kaggle) (1.3) Requirement already satisfied: idna&lt;3,&gt;=2.5 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (2.10) Requirement already satisfied: chardet&lt;4,&gt;=3.0.2 in /usr/local/lib/python3.6/dist-packages (from requests-&gt;kaggle) (3.0.4) 1.2. Kaggle Token 다운로드 Kaggle에서 API Token을 다운로드 받는다. [Kaggle]-[My Account]-[API]-[Create New API Token]을 누르면 kaggle.json 파일이 다운로드 된다. 이 파일을 바탕화면에 옮긴 뒤, 아래 코드를 실행 시킨다. 12345678from google.colab import filesuploaded = files.upload()for fn in uploaded.keys(): print(&#x27;uploaded file &quot;&#123;name&#125;&quot; with length &#123;length&#125; bytes&#x27;.format( name=fn, length=len(uploaded[fn]))) # kaggle.json을 아래 폴더로 옮긴 뒤, file을 사용할 수 있도록 권한을 부여한다. !mkdir -p ~/.kaggle/ &amp;&amp; mv kaggle.json ~/.kaggle/ &amp;&amp; chmod 600 ~/.kaggle/kaggle.json Upload widget is only available when the cell has been executed in the current browser session. Please rerun this cell to enable. Saving kaggle.json to kaggle.json uploaded file &quot;kaggle.json&quot; with length 67 bytes 1ls -1ha ~/.kaggle/kaggle.json /root/.kaggle/kaggle.json 에러 메시지가 없으면 성공적으로 json 파일이 업로드 되었다는 뜻이다. 1.3. Kaggle 데이터 불러오기 먼저 kaggle competition list를 불러온다. 1!kaggle competitions list Warning: Looks like you&#39;re using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) ref deadline category reward teamCount userHasEntered --------------------------------------------- ------------------- --------------- --------- --------- -------------- contradictory-my-dear-watson 2030-07-01 23:59:00 Getting Started Prizes 134 False gan-getting-started 2030-07-01 23:59:00 Getting Started Prizes 185 False tpu-getting-started 2030-06-03 23:59:00 Getting Started Knowledge 316 False digit-recognizer 2030-01-01 00:00:00 Getting Started Knowledge 2365 False titanic 2030-01-01 00:00:00 Getting Started Knowledge 18166 True house-prices-advanced-regression-techniques 2030-01-01 00:00:00 Getting Started Knowledge 4561 True connectx 2030-01-01 00:00:00 Getting Started Knowledge 391 False nlp-getting-started 2030-01-01 00:00:00 Getting Started Knowledge 1190 False rock-paper-scissors 2021-02-01 23:59:00 Playground Prizes 186 False riiid-test-answer-prediction 2021-01-07 23:59:00 Featured $100,000 1474 False nfl-big-data-bowl-2021 2021-01-05 23:59:00 Analytics $100,000 0 False competitive-data-science-predict-future-sales 2020-12-31 23:59:00 Playground Kudos 9351 False halite-iv-playground-edition 2020-12-31 23:59:00 Playground Knowledge 43 False predict-volcanic-eruptions-ingv-oe 2020-12-28 23:59:00 Playground Swag 194 False hashcode-drone-delivery 2020-12-14 23:59:00 Playground Knowledge 79 False cdp-unlocking-climate-solutions 2020-12-02 23:59:00 Analytics $91,000 0 False lish-moa 2020-11-30 23:59:00 Research $30,000 3417 False google-football 2020-11-30 23:59:00 Featured $6,000 919 False conways-reverse-game-of-life-2020 2020-11-30 23:59:00 Playground Swag 131 False lyft-motion-prediction-autonomous-vehicles 2020-11-25 23:59:00 Featured $30,000 783 False 여기에서 참여하기 원하는 대회의 데이터셋을 불러오면 된다. !kaggle competitions download -c + 대회명 (위의 목록 중 찾아서 복사 붙여넣기하기) 1!kaggle competitions download -c titanic Warning: Looks like you&#39;re using an outdated API Version, please consider updating (server 1.5.9 / client 1.5.4) train.csv: Skipping, found more recently modified local copy (use --force to force download) test.csv: Skipping, found more recently modified local copy (use --force to force download) gender_submission.csv: Skipping, found more recently modified local copy (use --force to force download) 1!ls gender_submission.csv sample_data test.csv train.csv II. 데이터 확인2.1. EDA에 관한 필수 패키지를 설치12345678import pandas as pd #데이터 가공, 변환(dplyr)import pandas_profiling # 보고서 기능 #아나콘다 할때import numpy as np #수치연산 &amp; 배열, 행렬import matplotlib as mpl #시각화import matplotlib.pyplot as plt #시각화import seaborn as sns #시각화from IPython.core.display import display, HTML 2.2. 데이터 수집123train = pd.read_csv(&#x27;train.csv&#x27;)test = pd.read_csv(&#x27;test.csv&#x27;)print(&quot;data import is done&quot;) data import is done 2.3. 데이터 확인 Kaggle 데이터를 불러오면 우선 확인해야 하는 것은 데이터셋의 크기다. 변수의 갯수 Numeric 변수 &amp; Categorical 변수의 개수 등을 파악해야 한다. Point 1 - train데이터에서 굳이 훈련데이터와 테스트 데이터를 구분할 필요는 없다. 보통 Kaggle에서는 테스트 데이터를 주기적으로 업데이트 해준다. Point 2 - 보통 test 데이터의 변수의 개수가 하나 더 작다. 1train.shape, test.shape ((891, 12), (418, 11)) 1train.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 PassengerId 891 non-null int64 1 Survived 891 non-null int64 2 Pclass 891 non-null int64 3 Name 891 non-null object 4 Sex 891 non-null object 5 Age 714 non-null float64 6 SibSp 891 non-null int64 7 Parch 891 non-null int64 8 Ticket 891 non-null object 9 Fare 891 non-null float64 10 Cabin 204 non-null object 11 Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.7+ KB 그 후 train데이터의 상위 5개의 데이터만 확인한다. 1display(train.head()) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 그 다음 확인해야 하는 것은 Numerical 변수와 Categorical 변수를 구분한다. 먼저 numerical_features를 구분하자. include=[np.number]는 Numerical 변수를 알려주고, exclude=[np.number]는 Categorical 변수를 알려준다. 123numeric_features = train.select_dtypes(include=[np.number]) # 수치형 데이터print(numeric_features.columns)print(&quot;The total number of numeric features are: &quot;, len(numeric_features.columns)) Index([&#39;PassengerId&#39;, &#39;Survived&#39;, &#39;Pclass&#39;, &#39;Age&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Fare&#39;], dtype=&#39;object&#39;) The total number of numeric features are: 7 numeric_features을 제외한 나머지 변수를 추출하자. 123categorical_features = train.select_dtypes(exclude=[np.number])print(categorical_features.columns)print(&quot;The total number of numeric features are: &quot;, len(categorical_features.columns)) Index([&#39;Name&#39;, &#39;Sex&#39;, &#39;Ticket&#39;, &#39;Cabin&#39;, &#39;Embarked&#39;], dtype=&#39;object&#39;) The total number of numeric features are: 5 III. 데이터 따라하기 https://www.kaggle.com/ash316/eda-to-prediction-dietanic 3.1. 데이터 탐색 EDA(Exploratory Data Analysis) 필요한 패키지 설치 12345678import numpy as np #수치연산 &amp; 배열, 행렬import pandas as pd #데이터 가공, 변환(dplyr)import matplotlib.pyplot as plt #시각화import seaborn as sns #시각화plt.style.use(&#x27;fivethirtyeight&#x27;) #시각화 스타일 설정import warnings # 경고 메세지 무시warnings.filterwarnings(&#x27;ignore&#x27;)%matplotlib inline 데이터 확인 12data=pd.read_csv(&#x27;train.csv&#x27;)data.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 1data.isnull().sum() #결측값 확인 PassengerId 0 Survived 0 Pclass 0 Name 0 Sex 0 Age 177 SibSp 0 Parch 0 Ticket 0 Fare 0 Cabin 687 Embarked 2 dtype: int64 Age, Cabin, Embarked에 결측값이 존재한다. 이 값을 수정할 필요가 있다. 1234567f,ax=plt.subplots(1,2,figsize=(18,8))data[&#x27;Survived&#x27;].value_counts().plot.pie(explode=[0,0.1],autopct=&#x27;%1.1f%%&#x27;,ax=ax[0],shadow=True)ax[0].set_title(&#x27;Survived&#x27;) #왼쪽 그래프 제목 넣기ax[0].set_ylabel(&#x27;&#x27;)sns.countplot(&#x27;Survived&#x27;,data=data,ax=ax[1])ax[1].set_title(&#x27;Survived&#x27;) #오른쪽 그래프 제목 넣기plt.show() 전체 인원 중 38.4%만 살아남았다. 데이터로부터 더 나은 통찰력을 얻고 어떤 범주의 승객들이 살아남았는지 그리고 누가 살아남지 않았는지 보기 위해 더 많은 정보를 분석해야한다. 3.2.Types Of Features 범주형 피쳐(Categorical Features): 범주형 변수는 두 개 이상의 범주를 가진 변수이다. 해당 형상의 각 값은 범주별로 분류할 수 있다. 이러한 변수들에 대해 어떠한 순서도 정렬할 수 없다. 데이터: Sex(남성과 여성), Embarked(S, C) 순서형 피쳐(Ordinal Features): 순서형 변수는 범주형 값과 비슷하지만, 그 값들 사이의 차이는 우리가 상대적인 순서나 값들 사이의 정렬을 가질 수 있다는 것이다. 예를 들어 높이에 높은 값, 중간 값, 짧은 값과 같은 특징이 있다면 높이는 순서형 변수다. 데이터: PClass 연속형 피쳐(Continous Feature): 피쳐 열의 두 점 또는 최소값 또는 최대값 사이에 값이 연속되는 경우 데이터: Age 3.3. Analysing The FeaturesSex–&gt; Categorical Feature1data.groupby([&#x27;Sex&#x27;,&#x27;Survived&#x27;])[&#x27;Survived&#x27;].count() #데이터 요약 Sex Survived female 0 81 1 233 male 0 468 1 109 Name: Survived, dtype: int64 123456f,ax=plt.subplots(1,2,figsize=(18,8))data[[&#x27;Sex&#x27;,&#x27;Survived&#x27;]].groupby([&#x27;Sex&#x27;]).mean().plot.bar(ax=ax[0]) #성별 생존자 비율ax[0].set_title(&#x27;Survived vs Sex&#x27;)sns.countplot(&#x27;Sex&#x27;,hue=&#x27;Survived&#x27;,data=data,ax=ax[1]) #성별 생존자, 사망자 수ax[1].set_title(&#x27;Sex:Survived vs Dead&#x27;)plt.show() 배에 타고 있는 남자들의 수가 여자들의 수보다 훨씬 많다. 그러나 구조된 여성의 수는 구조된 남성의 수보다 거의 두 배나 많다. 배에 타고 있는 여성의 생존율은 약 75%인 반면 남성은 약 18-19%이다. 1### Pclass --&gt; Ordinal Feature 1pd.crosstab(data.Pclass,data.Survived,margins=True).style.background_gradient(cmap=&#x27;summer_r&#x27;) #좌석 등급별 생존자 수 분류 #T_0414f32c_1e99_11eb_94db_0242ac1c0002row0_col0,#T_0414f32c_1e99_11eb_94db_0242ac1c0002row1_col1,#T_0414f32c_1e99_11eb_94db_0242ac1c0002row1_col2{ background-color: #ffff66; color: #000000; }#T_0414f32c_1e99_11eb_94db_0242ac1c0002row0_col1{ background-color: #cee666; color: #000000; }#T_0414f32c_1e99_11eb_94db_0242ac1c0002row0_col2{ background-color: #f4fa66; color: #000000; }#T_0414f32c_1e99_11eb_94db_0242ac1c0002row1_col0{ background-color: #f6fa66; color: #000000; }#T_0414f32c_1e99_11eb_94db_0242ac1c0002row2_col0{ background-color: #60b066; color: #000000; }#T_0414f32c_1e99_11eb_94db_0242ac1c0002row2_col1{ background-color: #dfef66; color: #000000; }#T_0414f32c_1e99_11eb_94db_0242ac1c0002row2_col2{ background-color: #90c866; color: #000000; }#T_0414f32c_1e99_11eb_94db_0242ac1c0002row3_col0,#T_0414f32c_1e99_11eb_94db_0242ac1c0002row3_col1,#T_0414f32c_1e99_11eb_94db_0242ac1c0002row3_col2{ background-color: #008066; color: #f1f1f1; } Survived 0 1 All Pclass 1 80 136 216 2 97 87 184 3 372 119 491 All 549 342 891 1234567f,ax=plt.subplots(1,2,figsize=(18,8))data[&#x27;Pclass&#x27;].value_counts().plot.bar(color=[&#x27;#CD7F32&#x27;,&#x27;#FFDF00&#x27;,&#x27;#D3D3D3&#x27;],ax=ax[0]) #좌석 등급별 승객 수ax[0].set_title(&#x27;Number Of Passengers By Pclass&#x27;)ax[0].set_ylabel(&#x27;Count&#x27;)sns.countplot(&#x27;Pclass&#x27;,hue=&#x27;Survived&#x27;,data=data,ax=ax[1]) #좌석 등급별 생존자, 사망자 수ax[1].set_title(&#x27;Pclass:Survived vs Dead&#x27;)plt.show() PClass 1의 승객이 구조 당시 높은 우선순위를 부여받았다는 것을 분명히 알 수 있다. PClass 3의 탑승객 수가 훨씬 더 많았지만, 여전히 탑승객들로부터 생존하는 사람들의 수는 약 25%로 매우 낮다. Pclass1의 생존율이 약 63%인 반면 Pclass2의 경우 약 48%이다. Sex와 Pclass의 데이터를 합쳐 생존율을 확인해보자. 12pd.crosstab([data.Sex,data.Survived],data.Pclass,margins=True).style.background_gradient(cmap=&#x27;summer_r&#x27;) #성별 좌석 등급별 생존자 수 분류#margins은 합계표시여부 #T_045dbfe4_1e99_11eb_94db_0242ac1c0002row0_col0,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row0_col1,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row0_col3,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row3_col2{ background-color: #ffff66; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row0_col2,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row1_col2{ background-color: #f1f866; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row1_col0{ background-color: #96cb66; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row1_col1{ background-color: #a3d166; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row1_col3{ background-color: #cfe766; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row2_col0{ background-color: #a7d366; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row2_col1,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row2_col3{ background-color: #85c266; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row2_col2{ background-color: #6eb666; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row3_col0{ background-color: #cde666; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row3_col1{ background-color: #f0f866; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row3_col3{ background-color: #f7fb66; color: #000000; }#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row4_col0,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row4_col1,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row4_col2,#T_045dbfe4_1e99_11eb_94db_0242ac1c0002row4_col3{ background-color: #008066; color: #f1f1f1; } Pclass 1 2 3 All Sex Survived female 0 3 6 72 81 1 91 70 72 233 male 0 77 91 300 468 1 45 17 47 109 All 216 184 491 891 12sns.factorplot(&#x27;Pclass&#x27;,&#x27;Survived&#x27;,hue=&#x27;Sex&#x27;,data=data) #성별 좌석 등급별 생존률 시각화plt.show() 범주형 값을 쉽게 분리하기 위해 FactorPlot을 사용하였다. CrossTab과 FactorPlot을 보면 여성 94명 중 3명만이 사망했기 때문에 Pclass1 여성 생존율이 약 95~96%라고 쉽게 유추할 수 있다. Pclass와 관계 없이 구조하는 동안 여성에게 구조우선권이 주어졌다는 것은 명백하다. Pclass1 출신의 남성들의 생존율 또한 매우 낮다. Age–&gt; Continous Feature123print(&#x27;Oldest Passenger was of:&#x27;,data[&#x27;Age&#x27;].max(),&#x27;Years&#x27;) #나이 최대값 표시print(&#x27;Youngest Passenger was of:&#x27;,data[&#x27;Age&#x27;].min(),&#x27;Years&#x27;) #나이 최솟값 표시print(&#x27;Average Age on the ship:&#x27;,data[&#x27;Age&#x27;].mean(),&#x27;Years&#x27;) #평균 나이 표시 Oldest Passenger was of: 80.0 Years Youngest Passenger was of: 0.42 Years Average Age on the ship: 29.69911764705882 Years 12345678f,ax=plt.subplots(1,2,figsize=(18,8))sns.violinplot(&quot;Pclass&quot;,&quot;Age&quot;, hue=&quot;Survived&quot;, data=data,split=True,ax=ax[0]) #나이별 좌석등급별 생존자 수 비교 (x축, y축, 범례)ax[0].set_title(&#x27;Pclass and Age vs Survived&#x27;)ax[0].set_yticks(range(0,110,10))sns.violinplot(&quot;Sex&quot;,&quot;Age&quot;, hue=&quot;Survived&quot;, data=data,split=True,ax=ax[1]) #나이별 성별 생존자 수 비교 (x축, y축, 범례)ax[1].set_title(&#x27;Sex and Age vs Survived&#x27;)ax[1].set_yticks(range(0,110,10))plt.show() Pclass가 증가함에 따라 어린 승객의 수가 증가한다. 10세 미만 승객의 생존율은 Pclass에 관계없이 양호한 편이다. Pclass1에서 20-50세의 생존률은 높고 여성은 특히 더 높다. 남성의 경우 나이 많을수록 생존률이 줄어든다. Age 카테고리의 결측값은 177개이다. 이러한 결측값을 대체하기 위해 데이터 집합의 평균 연령을 할당할 수 있다. 하지만 우리는 너무 다른 나이에(예를 들어 4살) 평균값(29세)를 대입할 수는 없다. 우리는 이름에 Mr. 와 Mrs.를 통해 성별을 예측하고 각 그룹에 맞는 평균을 대입할 수 있다. 123data[&#x27;Initial&#x27;]=0for i in data: data[&#x27;Initial&#x27;]=data.Name.str.extract(&#x27;([A-Za-z]+)\\.&#x27;) #lets extract the Salutations Regex를 사용하자. [A-Za-z]+). A-Z 또는 a-z 사이에 있는 문자열을 찾고, 그 뒤에 .(점)이 있는 문자열을 찾는다. 그러면 이름에서 이니셜을 성공적으로 추출할 수 있다. 1pd.crosstab(data.Initial,data.Sex).T.style.background_gradient(cmap=&#x27;summer_r&#x27;) #Checking the Initials with the Sex #T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col0,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col1,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col3,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col4,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col5,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col7,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col8,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col12,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col15,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col16,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col2,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col6,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col9,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col10,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col11,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col13,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col14{ background-color: #ffff66; color: #000000; }#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col2,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col6,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col9,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col10,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col11,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col13,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row0_col14,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col0,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col1,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col3,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col4,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col5,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col7,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col8,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col12,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col15,#T_04fd3664_1e99_11eb_94db_0242ac1c0002row1_col16{ background-color: #008066; color: #f1f1f1; } Initial Capt Col Countess Don Dr Jonkheer Lady Major Master Miss Mlle Mme Mr Mrs Ms Rev Sir Sex female 0 0 1 0 1 0 1 0 0 182 2 1 0 125 1 0 0 male 1 2 0 1 6 1 0 2 40 0 0 0 517 0 0 6 1 Mlle나 Mme 같이 Miss를 나타내는데 철자가 틀린 단어들을 수정할 필요가 있다. 12data[&#x27;Initial&#x27;].replace([&#x27;Mlle&#x27;,&#x27;Mme&#x27;,&#x27;Ms&#x27;,&#x27;Dr&#x27;,&#x27;Major&#x27;,&#x27;Lady&#x27;,&#x27;Countess&#x27;,&#x27;Jonkheer&#x27;,&#x27;Col&#x27;,&#x27;Rev&#x27;,&#x27;Capt&#x27;,&#x27;Sir&#x27;,&#x27;Don&#x27;],[&#x27;Miss&#x27;,&#x27;Miss&#x27;,&#x27;Miss&#x27;,&#x27;Mr&#x27;,&#x27;Mr&#x27;,&#x27;Mrs&#x27;,&#x27;Mrs&#x27;,&#x27;Other&#x27;,&#x27;Other&#x27;,&#x27;Other&#x27;,&#x27;Mr&#x27;,&#x27;Mr&#x27;,&#x27;Mr&#x27;],inplace=True)data.groupby(&#x27;Initial&#x27;)[&#x27;Age&#x27;].mean() #lets check the average age by Initials Initial Master 4.574167 Miss 21.860000 Mr 32.739609 Mrs 35.981818 Other 45.888889 Name: Age, dtype: float64 Age의 결측값을 채워보자 12345678## Assigning the NaN Values with the Ceil values of the mean agesdata.loc[(data.Age.isnull())&amp;(data.Initial==&#x27;Mr&#x27;),&#x27;Age&#x27;]=33data.loc[(data.Age.isnull())&amp;(data.Initial==&#x27;Mrs&#x27;),&#x27;Age&#x27;]=36data.loc[(data.Age.isnull())&amp;(data.Initial==&#x27;Master&#x27;),&#x27;Age&#x27;]=5data.loc[(data.Age.isnull())&amp;(data.Initial==&#x27;Miss&#x27;),&#x27;Age&#x27;]=22data.loc[(data.Age.isnull())&amp;(data.Initial==&#x27;Other&#x27;),&#x27;Age&#x27;]=46data.Age.isnull().any() #So no null values left finally False 12345678910f,ax=plt.subplots(1,2,figsize=(20,10))data[data[&#x27;Survived&#x27;]==0].Age.plot.hist(ax=ax[0],bins=20,edgecolor=&#x27;black&#x27;,color=&#x27;red&#x27;)ax[0].set_title(&#x27;Survived= 0&#x27;)x1=list(range(0,85,5))ax[0].set_xticks(x1)data[data[&#x27;Survived&#x27;]==1].Age.plot.hist(ax=ax[1],color=&#x27;green&#x27;,bins=20,edgecolor=&#x27;black&#x27;)ax[1].set_title(&#x27;Survived= 1&#x27;)x2=list(range(0,85,5))ax[1].set_xticks(x2)plt.show() 5세 미만의 아이들이 많이 생존한 것을 확인할 수 있다. 나이가 가장 많은 80세 승객은 생존한 것을 확인할 수 있다. 30-40 연령의 승객들의 사망자 수가 가장 큰 것을 확인할 수 있다. 12sns.factorplot(&#x27;Pclass&#x27;,&#x27;Survived&#x27;,col=&#x27;Initial&#x27;,data=data)plt.show() 모든 연령층에서 여성과 아동이 우선적으로 구조되었다는 것을 확인할 수 있다. Embarked–&gt; Categorical Value Embarked: 탑승 항구 C = Cherbourg Q = Queenstown S = Southampton 1pd.crosstab([data.Embarked,data.Pclass],[data.Sex,data.Survived],margins=True).style.background_gradient(cmap=&#x27;summer_r&#x27;) #T_06102e62_1e99_11eb_94db_0242ac1c0002row0_col0,#T_06102e62_1e99_11eb_94db_0242ac1c0002row1_col2{ background-color: #fcfe66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row0_col1{ background-color: #d2e866; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row0_col2{ background-color: #f2f866; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row0_col3{ background-color: #d8ec66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row0_col4,#T_06102e62_1e99_11eb_94db_0242ac1c0002row2_col3{ background-color: #e8f466; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row1_col0,#T_06102e62_1e99_11eb_94db_0242ac1c0002row3_col0,#T_06102e62_1e99_11eb_94db_0242ac1c0002row3_col1,#T_06102e62_1e99_11eb_94db_0242ac1c0002row3_col2,#T_06102e62_1e99_11eb_94db_0242ac1c0002row3_col3,#T_06102e62_1e99_11eb_94db_0242ac1c0002row3_col4,#T_06102e62_1e99_11eb_94db_0242ac1c0002row4_col0,#T_06102e62_1e99_11eb_94db_0242ac1c0002row4_col2,#T_06102e62_1e99_11eb_94db_0242ac1c0002row4_col3,#T_06102e62_1e99_11eb_94db_0242ac1c0002row4_col4{ background-color: #ffff66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row1_col1,#T_06102e62_1e99_11eb_94db_0242ac1c0002row6_col0{ background-color: #f9fc66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row1_col3,#T_06102e62_1e99_11eb_94db_0242ac1c0002row1_col4{ background-color: #fbfd66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row2_col0,#T_06102e62_1e99_11eb_94db_0242ac1c0002row5_col1{ background-color: #e6f266; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row2_col1{ background-color: #f0f866; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row2_col2{ background-color: #eef666; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row2_col4,#T_06102e62_1e99_11eb_94db_0242ac1c0002row7_col0{ background-color: #edf666; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row4_col1{ background-color: #fefe66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row5_col0{ background-color: #e3f166; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row5_col2{ background-color: #ecf666; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row5_col3{ background-color: #f8fc66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row5_col4{ background-color: #ebf566; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row6_col1{ background-color: #cde666; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row6_col2{ background-color: #e4f266; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row6_col3{ background-color: #bede66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row6_col4{ background-color: #dbed66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row7_col1{ background-color: #bdde66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row7_col2{ background-color: #d3e966; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row7_col3,#T_06102e62_1e99_11eb_94db_0242ac1c0002row8_col1{ background-color: #dcee66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row7_col4{ background-color: #d1e866; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row8_col0{ background-color: #52a866; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row8_col2{ background-color: #81c066; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row8_col3{ background-color: #b0d866; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row8_col4{ background-color: #9acc66; color: #000000; }#T_06102e62_1e99_11eb_94db_0242ac1c0002row9_col0,#T_06102e62_1e99_11eb_94db_0242ac1c0002row9_col1,#T_06102e62_1e99_11eb_94db_0242ac1c0002row9_col2,#T_06102e62_1e99_11eb_94db_0242ac1c0002row9_col3,#T_06102e62_1e99_11eb_94db_0242ac1c0002row9_col4{ background-color: #008066; color: #f1f1f1; } Sex female male All Survived 0 1 0 1 Embarked Pclass C 1 1 42 25 17 85 2 0 7 8 2 17 3 8 15 33 10 66 Q 1 0 1 1 0 2 2 0 2 1 0 3 3 9 24 36 3 72 S 1 2 46 51 28 127 2 6 61 82 15 164 3 55 33 231 34 353 All 81 231 468 109 889 항구별 생존률 1234sns.factorplot(&#x27;Embarked&#x27;,&#x27;Survived&#x27;,data=data)fig=plt.gcf()fig.set_size_inches(5,3)plt.show() 항구 C에서 생존률이 0.55로 가장 높고, 항구 S에서 가장 낮다. 1234567891011f,ax=plt.subplots(2,2,figsize=(20,15))sns.countplot(&#x27;Embarked&#x27;,data=data,ax=ax[0,0]) #항구별 승객 수ax[0,0].set_title(&#x27;No. Of Passengers Boarded&#x27;)sns.countplot(&#x27;Embarked&#x27;,hue=&#x27;Sex&#x27;,data=data,ax=ax[0,1]) #항구별 성별 승객 수ax[0,1].set_title(&#x27;Male-Female Split for Embarked&#x27;)sns.countplot(&#x27;Embarked&#x27;,hue=&#x27;Survived&#x27;,data=data,ax=ax[1,0]) #항구별 생존자, 사망자 수ax[1,0].set_title(&#x27;Embarked vs Survived&#x27;)sns.countplot(&#x27;Embarked&#x27;,hue=&#x27;Pclass&#x27;,data=data,ax=ax[1,1]) #항구별 등급별 승객 수ax[1,1].set_title(&#x27;Embarked vs Pclass&#x27;)plt.subplots_adjust(wspace=0.2,hspace=0.5)plt.show() 승객이 가장 많이 탄 항구는 S이며, Pclass3 의 승객이 많은 비중을 차지한다. 항구 C에서 승선한 승객들의 생존률이 높다. 그 이유는 Pclass1과 2 등급의 비중이 높아 구조가 잘 이루어진 것으로 보인다. 항구 S의 생존률이 낮은 이유는 Pclass3의 승객들이 많기 때문으로 보여진다. Pclass3의 승객들은 약 81% 정도가 생존하지 못하였다. 항구 Q에서 승선한 승객들의 약 95%는 Pclass3 등급의 승객들이다. 12sns.factorplot(&#x27;Pclass&#x27;,&#x27;Survived&#x27;,hue=&#x27;Sex&#x27;,col=&#x27;Embarked&#x27;,data=data)plt.show() Pclass1 과 Pclass2 여성들의 생존률은 거의 1에 가깝다. 항구 S의 승객들은 남녀 모두 생존률이 매우 낮다. 항구 Q의 남자 승객들은 Pclass 상관없이 생존률이 매우 낮다. Embarked의 결측값(NaN) 채우기 항구 S의 승객들이 가장 많으므로 결측값(NaN)을 S로 대체하도록 하자. 12data[&#x27;Embarked&#x27;].fillna(&#x27;S&#x27;,inplace=True)data.Embarked.isnull().any()# Finally No NaN values False SibSp–&gt; Discrete Feature 이 항목은 승객들이 혼자인지 가족과 함께 승선했는지를 나타낸다.(일행이 있는지를 나타냄) Sibling = brother, sister, stepbrother, stepsister Spouse = husband, wife 1pd.crosstab([data.SibSp],data.Survived).style.background_gradient(cmap=&#x27;summer_r&#x27;) #T_07600b84_1e99_11eb_94db_0242ac1c0002row0_col0,#T_07600b84_1e99_11eb_94db_0242ac1c0002row0_col1{ background-color: #008066; color: #f1f1f1; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row1_col0{ background-color: #c4e266; color: #000000; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row1_col1{ background-color: #77bb66; color: #000000; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row2_col0,#T_07600b84_1e99_11eb_94db_0242ac1c0002row4_col0{ background-color: #f9fc66; color: #000000; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row2_col1{ background-color: #f0f866; color: #000000; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row3_col0,#T_07600b84_1e99_11eb_94db_0242ac1c0002row3_col1{ background-color: #fbfd66; color: #000000; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row4_col1{ background-color: #fcfe66; color: #000000; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row5_col0,#T_07600b84_1e99_11eb_94db_0242ac1c0002row5_col1,#T_07600b84_1e99_11eb_94db_0242ac1c0002row6_col1{ background-color: #ffff66; color: #000000; }#T_07600b84_1e99_11eb_94db_0242ac1c0002row6_col0{ background-color: #fefe66; color: #000000; } Survived 0 1 SibSp 0 398 210 1 97 112 2 15 13 3 12 4 4 15 3 5 5 0 8 7 0 1234567f,ax=plt.subplots(1,2,figsize=(20,8))sns.barplot(&#x27;SibSp&#x27;,&#x27;Survived&#x27;,data=data,ax=ax[0])ax[0].set_title(&#x27;SibSp vs Survived&#x27;)sns.factorplot(&#x27;SibSp&#x27;,&#x27;Survived&#x27;,data=data,ax=ax[1])ax[1].set_title(&#x27;SibSp vs Survived&#x27;)plt.close(2)plt.show() 1pd.crosstab(data.SibSp,data.Pclass).style.background_gradient(cmap=&#x27;summer_r&#x27;) #T_07e66968_1e99_11eb_94db_0242ac1c0002row0_col0,#T_07e66968_1e99_11eb_94db_0242ac1c0002row0_col1,#T_07e66968_1e99_11eb_94db_0242ac1c0002row0_col2{ background-color: #008066; color: #f1f1f1; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row1_col0{ background-color: #7bbd66; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row1_col1{ background-color: #8ac466; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row1_col2{ background-color: #c6e266; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row2_col0,#T_07e66968_1e99_11eb_94db_0242ac1c0002row4_col2{ background-color: #f6fa66; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row2_col1{ background-color: #eef666; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row2_col2{ background-color: #f8fc66; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row3_col0,#T_07e66968_1e99_11eb_94db_0242ac1c0002row3_col2{ background-color: #fafc66; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row3_col1{ background-color: #fdfe66; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row4_col0,#T_07e66968_1e99_11eb_94db_0242ac1c0002row4_col1,#T_07e66968_1e99_11eb_94db_0242ac1c0002row5_col0,#T_07e66968_1e99_11eb_94db_0242ac1c0002row5_col1,#T_07e66968_1e99_11eb_94db_0242ac1c0002row5_col2,#T_07e66968_1e99_11eb_94db_0242ac1c0002row6_col0,#T_07e66968_1e99_11eb_94db_0242ac1c0002row6_col1{ background-color: #ffff66; color: #000000; }#T_07e66968_1e99_11eb_94db_0242ac1c0002row6_col2{ background-color: #fefe66; color: #000000; } Pclass 1 2 3 SibSp 0 137 120 351 1 71 55 83 2 5 8 15 3 3 1 12 4 0 0 18 5 0 0 5 8 0 0 7 barplot 과 factorplot을 통해 혼자 탑승한 승객의 생존률이 34.5%라는 것을 알 수 있다. 동행자 수가 증가할수록 생존률이 감소한다. 5~8인의 가족 생존률은 0인데 Pclass3 등급의 고객이기 때문일 수도 있다. Parch1pd.crosstab(data.Parch,data.Pclass).style.background_gradient(cmap=&#x27;summer_r&#x27;) #T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row0_col0,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row0_col1,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row0_col2{ background-color: #008066; color: #f1f1f1; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row1_col0{ background-color: #cfe766; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row1_col1{ background-color: #c2e066; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row1_col2{ background-color: #dbed66; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row2_col0{ background-color: #dfef66; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row2_col1{ background-color: #e1f066; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row2_col2{ background-color: #e3f166; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row3_col0,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row4_col1,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row5_col0,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row5_col1,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row6_col0,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row6_col1,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row6_col2{ background-color: #ffff66; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row3_col1{ background-color: #fcfe66; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row3_col2,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row4_col0,#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row4_col2{ background-color: #fefe66; color: #000000; }#T_07ec6f0c_1e99_11eb_94db_0242ac1c0002row5_col2{ background-color: #fdfe66; color: #000000; } Pclass 1 2 3 Parch 0 163 134 381 1 31 32 55 2 21 16 43 3 0 2 3 4 1 0 3 5 0 0 5 6 0 0 1 위 crosstab은 Pclass3에 다인 가족이 있음을 보여준다. 1234567f,ax=plt.subplots(1,2,figsize=(20,8))sns.barplot(&#x27;Parch&#x27;,&#x27;Survived&#x27;,data=data,ax=ax[0])ax[0].set_title(&#x27;Parch vs Survived&#x27;)sns.factorplot(&#x27;Parch&#x27;,&#x27;Survived&#x27;,data=data,ax=ax[1])ax[1].set_title(&#x27;Parch vs Survived&#x27;)plt.close(2)plt.show() 부모를 동반한 승객들의 생존률이 높은 것을 확인할 수 있다. 하지만 동반 승객 숫자가 늘어날수록 생존률이 줄어든다. 1-3명의 동반 승객이 있는 경우 생존률이 높으며 혼자이거나 4명 이상인 경우 생존률이 낮다. Fare–&gt; Continous Feature123print(&#x27;Highest Fare was:&#x27;,data[&#x27;Fare&#x27;].max())print(&#x27;Lowest Fare was:&#x27;,data[&#x27;Fare&#x27;].min())print(&#x27;Average Fare was:&#x27;,data[&#x27;Fare&#x27;].mean()) Highest Fare was: 512.3292 Lowest Fare was: 0.0 Average Fare was: 32.2042079685746 요금을 보면 공짜로 탄 사람이 있는 것을 확인할 수 있다. 12345678f,ax=plt.subplots(1,3,figsize=(20,8))sns.distplot(data[data[&#x27;Pclass&#x27;]==1].Fare,ax=ax[0])ax[0].set_title(&#x27;Fares in Pclass 1&#x27;)sns.distplot(data[data[&#x27;Pclass&#x27;]==2].Fare,ax=ax[1])ax[1].set_title(&#x27;Fares in Pclass 2&#x27;)sns.distplot(data[data[&#x27;Pclass&#x27;]==3].Fare,ax=ax[2])ax[2].set_title(&#x27;Fares in Pclass 3&#x27;)plt.show() Pclass1의 fare에서 분포가 크며, 점차 감소한다. 연속된 값이기 때문에 bining을 사용하여 값을 변환할 수 있다. Observations in a Nutshell for all features Sex: 남성에 비해 여성의 생존률이 높다. Pclass: Pclass1의 생존률이 높으며, 반면에, Pclass3의 생존율은 매우 낮다. 여성의 경우 Pclass1에서 생존률은 거의 1이며 Pclass2에서의 생존률 또한 높다. Age: 5~10세 미만의 어린이들은 생존률이 높다. 15세에서 35세 사이의 승객들이 많이 죽었다. Embarked: Pclass1 승객의 대다수가 S에서 승선했음에도 불구하고, C에서 생존률이 더 높다. Q에서 승선한 승객들은 대부분 Pclass3 등급의 승객이다. Parch+SibSp: 형제자매 혹은 배우자가 있는 1-2명, 부모님이 같이 있는 1-3명에서의 생존률이 혼자 이거나, 대가족이 있는 사람의 생존률보다 더 높다. Correlation Between The Features1234sns.heatmap(data.corr(),annot=True,cmap=&#x27;RdYlGn&#x27;,linewidths=0.2) #data.corr()--&gt;correlation matrixfig=plt.gcf()fig.set_size_inches(10,8)plt.show() 3.4. Part2: Feature Engineering and Data Cleaning 불필요한 feature(중복자료) 제거 Age_band Age Feature의 문제점 Age는 연속적인 값이고, 머신러닝에 있어 연속적인 값에 관한 문제가 있다. Bining과 Nomalization을 통해 연속형 값을 범주형 값으로 변환해 줄 필요가 있다. binning을 사용하여 다양한 연령대를 하나의 bin으로 그룹화하거나 단일 값을 할당할 것이다. 0-80의 범위를 5개의 그룹으로 나눌 것이다.(16 크기의 5개 그룹) 1234567data[&#x27;Age_band&#x27;]=0data.loc[data[&#x27;Age&#x27;]&lt;=16,&#x27;Age_band&#x27;]=0data.loc[(data[&#x27;Age&#x27;]&gt;16)&amp;(data[&#x27;Age&#x27;]&lt;=32),&#x27;Age_band&#x27;]=1data.loc[(data[&#x27;Age&#x27;]&gt;32)&amp;(data[&#x27;Age&#x27;]&lt;=48),&#x27;Age_band&#x27;]=2data.loc[(data[&#x27;Age&#x27;]&gt;48)&amp;(data[&#x27;Age&#x27;]&lt;=64),&#x27;Age_band&#x27;]=3data.loc[data[&#x27;Age&#x27;]&gt;64,&#x27;Age_band&#x27;]=4data.head(2) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked Initial Age_band 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S Mr 1 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C Mrs 2 1data[&#x27;Age_band&#x27;].value_counts().to_frame().style.background_gradient(cmap=&#x27;summer&#x27;)#checking the number of passenegers in each band #T_09298e9a_1e99_11eb_94db_0242ac1c0002row0_col0{ background-color: #ffff66; color: #000000; }#T_09298e9a_1e99_11eb_94db_0242ac1c0002row1_col0{ background-color: #d8ec66; color: #000000; }#T_09298e9a_1e99_11eb_94db_0242ac1c0002row2_col0{ background-color: #40a066; color: #000000; }#T_09298e9a_1e99_11eb_94db_0242ac1c0002row3_col0{ background-color: #289366; color: #000000; }#T_09298e9a_1e99_11eb_94db_0242ac1c0002row4_col0{ background-color: #008066; color: #f1f1f1; } Age_band 1 382 2 325 0 104 3 69 4 11 12sns.factorplot(&#x27;Age_band&#x27;,&#x27;Survived&#x27;,data=data,col=&#x27;Pclass&#x27;)plt.show() Pclass에 상관없이 나이가 많을수록 생존률이 떨어진다. Family_Size and Alone Parch 와 SibSp Feature의 합을 통해 “Family_size”와 “Alone”이라는 Feature를 생성할 것이다. 이는 승객의 가족 규모와 생존률이 상관관계가 있는지 확인하기 위함이다. Alone은 승객이 혼자인지 아닌지를 나타낸다. 12345678910111213data[&#x27;Family_Size&#x27;]=0data[&#x27;Family_Size&#x27;]=data[&#x27;Parch&#x27;]+data[&#x27;SibSp&#x27;]#family sizedata[&#x27;Alone&#x27;]=0data.loc[data.Family_Size==0,&#x27;Alone&#x27;]=1#Alonef,ax=plt.subplots(1,2,figsize=(18,6))sns.factorplot(&#x27;Family_Size&#x27;,&#x27;Survived&#x27;,data=data,ax=ax[0])ax[0].set_title(&#x27;Family_Size vs Survived&#x27;)sns.factorplot(&#x27;Alone&#x27;,&#x27;Survived&#x27;,data=data,ax=ax[1])ax[1].set_title(&#x27;Alone vs Survived&#x27;)plt.close(2)plt.close(3)plt.show() Family_Size=0은 승객이 혼자인 것을 의미한다. 혼자 승선한 승객의 경우 생존률이 매우 낮다. Family size &gt; 4인 경우 또한 생존률이 감소한다. 12sns.factorplot(&#x27;Alone&#x27;,&#x27;Survived&#x27;,data=data,hue=&#x27;Sex&#x27;,col=&#x27;Pclass&#x27;)plt.show() Sex와 Pclass와 무관하게 혼자인 승객의 생존률은 좋지 않다. 예외적으로 Pclass3의 여성의 경우, 혼자인 경우가 가족이 있는 경우보다 생존률이 높다. Fare_Range Fare 또한 연속형 값을 갖기 때문에 서수 값으로 변환해 주어야 한다. pandas.qcut를 사용하여 변환할 것이다. qcut은 우리가 통과시킨 bin의 개수에 따라 분류할 것이다. 12data[&#x27;Fare_Range&#x27;]=pd.qcut(data[&#x27;Fare&#x27;],4)data.groupby([&#x27;Fare_Range&#x27;])[&#x27;Survived&#x27;].mean().to_frame().style.background_gradient(cmap=&#x27;summer_r&#x27;) #T_8982a520_1e9b_11eb_94db_0242ac1c0002row0_col0{ background-color: #ffff66; color: #000000; }#T_8982a520_1e9b_11eb_94db_0242ac1c0002row1_col0{ background-color: #b9dc66; color: #000000; }#T_8982a520_1e9b_11eb_94db_0242ac1c0002row2_col0{ background-color: #54aa66; color: #000000; }#T_8982a520_1e9b_11eb_94db_0242ac1c0002row3_col0{ background-color: #008066; color: #f1f1f1; } Survived Fare_Range (-0.001, 7.91] 0.197309 (7.91, 14.454] 0.303571 (14.454, 31.0] 0.454955 (31.0, 512.329] 0.581081 Fare_Range가 증가할수록 생존률 또한 증가하는 것을 확인할 수 있다. Fare_Range 값을 그대로 사용할 수 없으므로, singleton값으로 변환해 주어야 한다. 12345678data[&#x27;Fare_cat&#x27;]=0data.loc[data[&#x27;Fare&#x27;]&lt;=7.91,&#x27;Fare_cat&#x27;]=0data.loc[(data[&#x27;Fare&#x27;]&gt;7.91)&amp;(data[&#x27;Fare&#x27;]&lt;=14.454),&#x27;Fare_cat&#x27;]=1data.loc[(data[&#x27;Fare&#x27;]&gt;14.454)&amp;(data[&#x27;Fare&#x27;]&lt;=31),&#x27;Fare_cat&#x27;]=2data.loc[(data[&#x27;Fare&#x27;]&gt;31)&amp;(data[&#x27;Fare&#x27;]&lt;=513),&#x27;Fare_cat&#x27;]=3sns.factorplot(&#x27;Fare_cat&#x27;,&#x27;Survived&#x27;,data=data,hue=&#x27;Sex&#x27;)plt.show() Fare_cat이 증가할수록 생존률이 증가한다. Converting String Values into Numeric 머신러닝에 문자열 데이터를 사용할 수 없으므로, Sex, Embarked 등의 데이터를 숫자형 데이터로 변환해야 한다. 123data[&#x27;Sex&#x27;].replace([&#x27;male&#x27;,&#x27;female&#x27;],[0,1],inplace=True)data[&#x27;Embarked&#x27;].replace([&#x27;S&#x27;,&#x27;C&#x27;,&#x27;Q&#x27;],[0,1,2],inplace=True)data[&#x27;Initial&#x27;].replace([&#x27;Mr&#x27;,&#x27;Mrs&#x27;,&#x27;Miss&#x27;,&#x27;Master&#x27;,&#x27;Other&#x27;],[0,1,2,3,4],inplace=True) 불필요한 Feature 삭제 Name–&gt; 범주형 값으로 변환할 수 없으므로 삭제한다. Age–&gt; Age_band feature를 사용할 것이므로 삭제한다. Ticket–&gt; It is any random string that cannot be categorised. Fare–&gt; Fare_cat을 사용할 것이므로 삭제한다. Cabin–&gt; 결측값이 많고, 대부분의 승객들이 복수의 객실을 가지고 있으므로 필요없는 데이터이다. Fare_Range–&gt; Fare_cat을 사용할 것이므로 삭제한다. PassengerId–&gt; 분류할 수 없다. 1234567data.drop([&#x27;Name&#x27;,&#x27;Age&#x27;,&#x27;Ticket&#x27;,&#x27;Fare&#x27;,&#x27;Cabin&#x27;,&#x27;Fare_Range&#x27;,&#x27;PassengerId&#x27;],axis=1,inplace=True)sns.heatmap(data.corr(),annot=True,cmap=&#x27;RdYlGn&#x27;,linewidths=0.2,annot_kws=&#123;&#x27;size&#x27;:20&#125;)fig=plt.gcf()fig.set_size_inches(18,15)plt.xticks(fontsize=14)plt.yticks(fontsize=14)plt.show() 우리는 Feature간의 연관성을 확인할 수 있다. SibSp and Family_Size와 Parch and Family_Size처럼 양의 값이거나 Alone과 Family_Size와 같이 음의 값이다.","categories":[],"tags":[]},{"title":"Seaborn with Matplotlib (4)","slug":"Seaborn_with_Matplotlib_4","date":"2020-11-02T13:35:55.612Z","updated":"2020-11-03T14:28:52.462Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_4/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_4/","excerpt":"","text":"4. seaborn figure-level 다듬기 seaborn + matplotlib 마지막 시간입니다. figure-level 그림을 그리고 다듬어 봅니다. 자체적으로 지원하는 명령어를 사용해보고, 개흉 심장마사지 방법을 알아보겠습니다. seaborn API seaborn tutorial 4.1. figure-level으로 편리하게 그리기: pairplot()wikipedia: Exploratory data analysis wikipedia: Anscombe’s quartet autodesk: datasaurus seaborn.pairplot EDA에서 피할 수 없는 과정이 상관도입니다. 두 변수 사이의 관계를 그려 관계를 파악합니다. 대개 산점도scatter plot나 밀도 함수density plot를 쓰고, 추세선regression을 덧붙이는 경우도 있습니다. 데이터 분포는 통계값으로만 확인하면 안됩니다. 평균과 표준편차는 같은데 분포는 다른 경우가 많습니다. 반드시 분포를 그려 봐야 합니다. Anscombe’s quartet이 아주 좋은 예시입니다. N개의 인자 사이에는 \\(N(N−1)/2\\)가지 관계가 있습니다. seaborn의 pairplot()은 여러 인자 사이의 수많은 상관도를 쉽게 그려줍니다. 붓꽃iris 데이터셋으로 상관도를 그려봅니다. 꽃받침sepal과 꽃잎petal, 길이length와 폭width 네 가지 인자로부터 여섯 가지의 상관도, 네 가지의 히스토그램이 나옵니다. 코드 한 줄로 그려봅시다. 123import seaborn as snsiris = sns.load_dataset(&quot;iris&quot;) 종species별 분포를 그려봅니다. 1g = sns.pairplot(iris, hue=&quot;species&quot;) hue=라는 인자 하나만 추가했을 뿐입니다. 그림이 갑자기 예뻐졌습니다. 히스토그램도 밀도함수로 바뀌어서 훨씬 보기 좋습니다. 여기에 다른 그림을 겹쳐보겠습니다. 대각선 위 : 2차원 밀도함수 + 추세선 대각선 아래 : 2차원 밀도함수 + 산포도 seaborn figure-level 기능만으로 가능합니다. .map_lower()와 .map_upper를 사용합니다. 123g = sns.pairplot(iris, hue=&quot;species&quot;, kind=&quot;kde&quot;, plot_kws=&#123;&quot;alpha&quot;:0.3&#125;)g.map_lower(sns.scatterplot)g.map_upper(sns.regplot, scatter=False, truncate=False, ci=False) map_lower()와 map_upper()는 대각선의 위와 아래에 그림을 덧씌우는map 함수입니다. 앞서 완성한 pairplot에 새로운 그림을 덧붙입니다. 인자로는 함수 이름과 이 함수의 옵션들을 연달아 넣어 줍니다. 함수에 맞는 인자를 넣어줘야 합니다. 4.2. figure-level 그림 뼈대부터 세우기: PairGrid()seaborn.PairGrid pairplot을 단계별로 그리는 방법입니다. 코드 양은 pairplot()한 줄보다 늘어납니다. 그러나 자유도가 늘어납니다. .pairplot() 으로는 위 아래를 완전히 다르게 할 수 없습니다. 대각선의 아래엔 산점도와 추세선을 그리고 대각선 위에는 밀도함수만 그려보겠습니다. 123456789101112131415# 틀 만들기g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False)# diagonalg.map_diag(sns.kdeplot, fill=True)# lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)# upperg.map_upper(sns.kdeplot, alpha=0.3)# legendg.add_legend() .pairplot()과 같은 형식의 그림이 나왔습니다. 내 의도를 더 잘 반영할 수 있게 되었습니다. 8번째 줄에는 plt.scatter가 들어가 있습니다. .pairplot()도 마찬가지지만 .map()에는 seaborn대신 matplotlib - 함수를 사용할 수 있습니다. 중복되는 오른쪽 윗부분을 생략할 수 있습니다. corner=True를 넣어줍니다. 123456789101112g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)# lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendg.add_legend() 이제 작은 수정을 해봅니다. 대각선에 사각 테두리 치기 범례를 그림 안으로 가져오기 가슴을 열고 심장마사지를 할 시간입니다. 4.3. figure-level 그림 객체 접근seaborn.FacetGrid matplotlib.figure.Figure matplotlib.axes.Axes matplolib 그림은 figure와 axes로 나뉩니다. seaborn 그림도 결국 matplotlib 그림입니다. seaborn의 figure와 axes에 접근하면 됩니다. 4.3.1. axes: .axes 이전 글에서 axes를 이용해 jointplot을 재현했습니다. axes 객체는 .axes를 이용해 접근 가능합니다. 1g.axes 확인 결과 AxesSubplot의 array입니다. 4.3.1.1. 특정 axes 윤곽선 그리기Seaborn with Matplotlib (2) Spines &amp; Grids 정체를 알았으니 axes[i][j]로 접근할 수 있습니다. g.axes[i][j]의 spine을 보이게 합니다. 12345678910111213141516g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)for i in range(4): g.axes[i][i].spines[&quot;left&quot;].set_visible(True) g.axes[i][i].spines[&quot;top&quot;].set_visible(True) g.axes[i][i].spines[&quot;right&quot;].set_visible(True) # lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendg.add_legend() 4.3.1.2. 범례 조정seaborn axisgrid.py 소스코드 matplotlib.axes.Axes.get_legend_handles_labels matplotlib.axes.Axes.legend legend 정보를 가져와서 legend로 삽입합니다. 대개 legend에 필요한 handles와 labels는 .get_legend_handles_labels()로 가져옵니다. 하지만 seaborn figure-level 그림엔 이 명령이 통하지 않습니다. private처럼 보이는 ._legend_data를 사용합니다. 공식 문서에 없습니다. 소스 코드를 뒤적여야 합니다. ._legend_data 정체를 확인합니다. 범례가 dict 형식으로 들어 있습니다. 1g._legend_data 아래 코드를 추가하여 범례를 이동합니다. 12345678handles = g._legend_data.values()labels = g._legend_data.keys()# axes[1][0] 기준으로 오른쪽 멀리 범례 삽입g.axes[1][0].legend(handles=handles, labels=labels, bbox_to_anchor=(3.45, 1), fontsize=&quot;large&quot;, frameon=False ) 이런 방식으로 특정 axes만 제어할 수 있습니다. 원하는 그림, 글자을 넣을 수 있고 특정 데이터의 색상을 변경할 수 있습니다. 4.3.2. figure: .fig 개별 공간은 axes로 제어하지만 여러 axes가 연관된 공간은 figure로 제어합니다. figure 객체는 .fig를 이용해 접근 가능합니다 1type(g.fig) type()으로 감싸주지 않으면 그림이 통으로 출력됩니다. 4.3.2.1. ylabel alignmentmatplolib.figure.Figure #align_ylabels matplotlib Align y-labels 위 그림에서 ylabel 줄이 잘 맞지 않습니다. 맨 왼쪽 아래 axes[3][0]의 label이 비죽 나왔네요. 다른 ylabel을 움직여서 열을 맞춰 봅시다. 위 그림 코드의 맨 마지막 줄에 한 줄만 추가합니다 1g.fig.align_ylabels(g.axes[:,0]) 4.3.2.2. 범례 조정matplolib.figure.Figure #legend 범례는 figure 기준으로도 삽입 가능합니다. 아래 코드는 위의 axes[1][0].legend()와 동일합니다. 전체적인 그림의 위치를 잡을 수 있어 더 좋습니다. 123g.fig.legend(handles=handles, labels=labels, bbox_to_anchor=(0.75, 0.75), fontsize=&quot;large&quot;) 4.3.2.3. suptitlematplolib.figure.Figure #suptitle 그림 전체에 제목을 붙일 수 있습니다. 1234g.fig.suptitle(&quot;iris dataset&quot;, y=1.01, weight=&quot;bold&quot;, fontsize=&quot;x-large&quot; )g.fig.tight_layout() 4.3.2.4. facecolor, edgecolormatplolib.figure.Figure #set_facecolor 그림 바탕색을 칠합니다. 1g.fig.set_facecolor(&quot;whitesmoke&quot;) 4.3.3. 최종 x, ylabel까지 정리하면 이렇습니다. 123456789101112131415161718192021222324252627282930313233343536373839g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)for i in range(4): g.axes[i][i].spines[&quot;left&quot;].set_visible(True) g.axes[i][i].spines[&quot;top&quot;].set_visible(True) g.axes[i][i].spines[&quot;right&quot;].set_visible(True) # lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendhandles = g._legend_data.values()labels = g._legend_data.keys()g.fig.legend(handles=handles, labels=labels, bbox_to_anchor=(0.75, 0.75), fontsize=&quot;large&quot;)# x, y labelslabels = [&quot;Sepal Length&quot;, &quot;Sepal Width&quot;, &quot;Petal Length&quot;, &quot;Petal Width&quot;]font_labels = &#123;&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;&#125;for i in range(4): g.axes[3, i].set_xlabel(labels[i], fontdict=font_labels) g.axes[i, 0].set_ylabel(labels[i], fontdict=font_labels)# ylabel alignmentg.fig.align_ylabels(g.axes[:,0])# suptitleg.fig.suptitle(&quot;iris dataset&quot;, y=1.01, weight=&quot;bold&quot;, fontsize=&quot;x-large&quot; )g.fig.tight_layout()# facecolorg.fig.set_facecolor(&quot;whitesmoke&quot;) 5. 결론 네 편의 글에 걸쳐 matplotlib + seaborn 연계기를 정리했습니다. 개별적인 코드와 기술보다는 본질에 집중합시다. figure와 axes를 통하면 웬만한건 다 된다는 겁니다. 0.11에서 seaborn의 공식문서가 대폭 정리됐습니다. 하지만 아직 부족한 점이 많습니다. 특히 많은 경우 matplotlib에 숙달되었다고 전제합니다. 일단 matplotlib부터 제대로 익혀봅시다. 출저: https://jehyunlee.github.io/2020/10/10/Python-DS-37-seaborn_matplotlib4/","categories":[],"tags":[]},{"title":"Seaborn with Matplotlib (3)","slug":"Seaborn_with_Matplotlib_3","date":"2020-11-02T12:29:11.750Z","updated":"2020-11-02T14:37:11.816Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_3/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_3/","excerpt":"","text":"3. seaborn figure-level function seaborn의 핵심기능, 강력한 명령입니다. 4부 중 세 번째 시간입니다. matplotlib으로는 매우 수고스러울 일을 줄여줍니다. 그러나 손대기 어렵기도 합니다. 이유와 해결방법을 알아봅시다. seaborn API seaborn tutorial seaborn with matplotlib (1) 지난 글에서 matplotlib과 친한 함수를 알아봤습니다. 이런 axex 반환 함수를 axes-level 함수, 반대로 그림 전체를 반환하는 함수를 figure-level 함수라고 합니다. 아래 노란 부분이 figure-level 함수입니다. 반환 형식return type이 왜 이렇게 깔끔하지 않은지는 뒤에 보겠습니다. figure-level 함수는 복잡한 그림을 한 번에 편하게 그려줍니다. 3.1. figure-level 편리함 맛보기: FacetGrid() seaborn에 내장된 penguins dataset에는 이런 데이터가 있습니다. bill_length_mm : 부리 길이 bill_depth_mm : 부리 위아래 두께 species : 펭귄 종 sex : 성별 island : 서식지 이 데이터를 산점도로 한번에 나타내고자 합니다. X축 : bill_length_mm Y축 : bill_depth_mm 색상 : species X방향 axes : island Y방향 axes : sex matplotlib 코드는 이렇습니다. 12345678910111213141516171819202122232425262728293031fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(12, 8), sharex=True, sharey=True)# 인자별 데이터 종 수 세기sex = penguins[&quot;sex&quot;].dropna().unique()island = penguins[&quot;island&quot;].dropna().unique()species = penguins[&quot;species&quot;].dropna().unique()# X방향 axes: sexfor i in range(len(sex)): # Y방향 axes: island for j in range(len(island)): # 색상 : species for k in range(len(species)): try: axes[i][j].scatter(penguins.loc[penguins[&quot;sex&quot;] == sex[i]].loc[penguins[&quot;island&quot;] == island[j]].loc[penguins[&quot;species&quot;] == species[k]][&quot;bill_length_mm&quot;], penguins.loc[penguins[&quot;sex&quot;] == sex[i]].loc[penguins[&quot;island&quot;] == island[j]].loc[penguins[&quot;species&quot;] == species[k]][&quot;bill_depth_mm&quot;]) axes[i][j].set_title(f&quot;sex = &#123;sex[i]&#125; | island = &#123;island[j]&#125;&quot;) except: # 결측치 예외처리 pass # 맨 아래줄에만 xlabel 추가 axes[len(sex)-1, j].set_xlabel(&quot;bill_length_mm&quot;) # 맨 왼쪽에만 ylabel 추가 axes[i, 0].set_ylabel(&quot;bill_depth_mm&quot;)# 그래프 우측에 범례 표시fig.legend(species, title=&quot;species&quot;, bbox_to_anchor=(0.95, 0.5))# 그래프 간격 조정fig.tight_layout(rect=[0,0,0.85,1]) 따로 꾸민 것도 없는데 매우 번잡합니다. 인자별로 몇가지인지를 알아내야 합니다. 결측치 처리가 필요합니다. 안하면 에러납니다. 색상별로 따로 그려야 합니다. 그런데 seaborn을 사용하면 세 줄 만에 끝납니다. 123g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.scatterplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;)g.add_legend() FacetGrid()로 만든 공간을 .map()으로 채웁니다. 데이터셋 이름, 변수 이름, 그리는 방식 외에 다른 내용이 없습니다. 인자가 여럿인 관계를 보기에 아주 좋습니다. 밀도 함수density plot로 바꾸는 것도 간단합니다. 위 코드에서 sns.scatterplot만 sns.kdeplot으로 넣으면 됩니다. 123g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;)g.add_legend() figure-level 함수는 복잡한 그림을 간단히 그릴 때 매우 강력합니다. 이 그림들을 matplotlib으로 그리려면 얼마나 막막할까요. 3.2. figure-level 꾸미기: FacetGrid()seaborn.FacetGrid seaborn.kdeplot seaborn.regplot 이번엔 figure-level 그림을 꾸며 보겠습니다. kdeplot위에 추세선을 겹쳐 그립니다. 추세선이 중간에 안끊기면 좋겠습니다. 신뢰구간은 80% 수준으로 그리고 싶습니다. xlabel을 “Bill Length (mm)”로 바꾸고 ylabel을 “Bill Depth (mm)”로 바꿉니다. 공식 홈페이지의 설명에 힘입어 해냈습니다. 123456g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;)g.add_legend() 한 단계 더 꾸며보도록 합시다. xlabel, ylabel 글자를 키우고 싶습니다. 추세선의 신뢰구간 80%를 적어두고 싶습니다. axes마다 붙어 있는 title을 정리하고 싶습니다. 첫 단계에서 막혔습니다 xlabel, ylabel을 수정할 때 set_axis_labels()를 사용했습니다. 공식 홈페이지의 FacetGrid()부분 가이드를 따른 것입니다. 그런데 set_axis_labels()에 대한 설명이 더 이상 없습니다. 혹시나, matplotlib 명령어를 넣어봅니다. fontdict=를 적용합니다 1234567g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, fontdict=&#123;&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;&#125;)g.add_legend() figure-level 그림의 세부 설정은 도움말 찾기도 어렵습니다. 매뉴얼에 없는 내용을 상상해서 넣어야 합니다. 아직은 공식 홈페이지가 충만하지 않습니다. 소스코드를 뜯어봐서 기능을 확인하거나 matplotlib 명령어를 숙지하고 대응시켜 시도해야 합니다. 3.3. figure-level의 장단점 공식 튜토리얼에 정리된 장단점은 이렇습니다 하나씩 짚어보겠습니다. (1) 데이터 변수에 따른 축공간 생성 matplotlib에서 변수 갯수를 세어야 했던 것에 비해서 편리합니다. seaborn에 구현된 그림을 제어하는 인자 수가 확실히 적습니다. 번거롭더라도 axes에 직접 접근해서 matplotlib 명령을 쓰는 게 낫습니다. (2) 그림 밖 범례 생성 그림 밖에 붙는 것은 다행입니다. 그러나 통제가 안되어 심각한 갈증을 유발합니다. (3) figure-level 수정 &amp; (4) figure size를 조정하는 인자가 다름 장점보다 단점이 크다고 생각됩니다. 더 쉬운 명령어를 제공한다고 해도 결국은 또 다른 문법입니다. matplotlib 명령어만 해도 정신이 없는데 말이죠. 지금까지의 경험으로 이런 결론이 나옵니다. “figure-level의 가성비는 그리자마자, 손을 더 대기 전이 가장 높다.” 새로운 명령어는 새로운 혼돈입니다. 시각화만 붙잡고 있을 게 아니라 통계분석, 머신러닝도 해야 하거든요. 3.4. figure-level그림이 손대기 어려운 이유github: seaborn source code seaborn 코드를 뜯어보면 클래스 구조는 이렇습니다. multi-plot grids는 Grid 클래스를 상속받는 가족입니다. FacetGrid(), PairGrid(), ClusterGrid 입니다. JointGrid()는 Grid를 상속받지 않습니다. Grid로 만든 공간에 목적에 맞는 그림을 채웁니다. relplot(), displot(), catplot(), lmplot()은 1x1 FacetGrid()로 출력됩니다. 그리고 Grid 클래스는 **figure**의 wrapper입니다. 정확히는 matplotlib.pyplot.subplots()의 wrapper입니다. 따라서 figure, axes에 적용되는 matplotlib 명령이 안통합니다. 그래서 set_axis_labels같은 자체 명령어를 탑재하고 있습니다. 하지만 보셨다시피 도움말이 충분치 않습니다. 3.5. figure-level 그림을 꾸미는 방법Doctor! The heart’s stopped! 한마디로, seaborn 제공 함수는 한계가 큽니다. 기능 자체도 많이 빠져있고 있는 기능도 문서화가 덜 됐습니다. 이걸 믿고 쓰긴 어렵습니다. 하지만 대안이 있습니다. seaborn 그림을 matplotlib 그림으로 간주합니다. figure-level 객체 안으로 한 걸음 들어갑니다. 그리고 figure와 axes를 직접 건드립니다. 개흉 심장마사지를 상상하시면 됩니다. 가슴을 열고 직접 심장을 마사지하는 겁니다. 그러면, 풀지 못했던 난제도 이렇게 풀립니다. 1234567891011121314151617181920212223242526272829g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;, margin_titles=True, despine=False)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.add_legend()# xlabel, ylabel 수정g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, fontdict=&#123;&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;&#125;)# axes 직접 접근, 1차원 행렬로 표현axs = g.axes.ravel()for i, ax in enumerate(axs): # 열 title 수정 if i &lt; 3: ax.set_title(ax.get_title(), fontdict=&#123;&quot;fontsize&quot;:&quot;x-large&quot;, &quot;color&quot;:&quot;k&quot;&#125;, pad=12) # 행 title 수정 if i%3 == 2: sex = &quot;Male&quot; if i == 2 else &quot;Female&quot; ax.texts.clear() text = ax.annotate(f&quot;sex = &#123;sex&#125;&quot;, xy=(1.02, .5), xycoords=&quot;axes fraction&quot;, rotation=270, ha=&quot;left&quot;, va=&quot;center&quot;, fontsize=&quot;x-large&quot;, color=&quot;k&quot;)# suptitle 추가g.fig.suptitle(&quot;Penguins dataset summary (ci = 80%) &quot;, fontsize=&quot;xx-large&quot;, fontweight=&quot;bold&quot;, color=&quot;indigo&quot;)# 전반적 크기 조정 g.fig.tight_layout(rect=[0,0,0.88,0.97]) 외웁시다. figure-level 함수는 matplotlib과 못 섞는다. figure-level 함수는 figure와 axes를 한번 더 감싸고 있다. figure-level 함수를 수정하려면 후벼 파는 과정이 필요하다. 출저: https://jehyunlee.github.io/2020/10/06/Python-DS-36-seaborn_matplotlib3/","categories":[],"tags":[]},{"title":"Seaborn with Matplotlib (2)","slug":"Seaborn_with_Matplotlib_2","date":"2020-11-02T06:27:20.705Z","updated":"2020-11-02T07:02:20.062Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_2/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_2/","excerpt":"","text":"2. seaborn + matplotlib을 이용한 jointplot 보완 seaborn을 matplotlib과 섞어쓰는 방법입니다. 4부 중 두 번째 시간입니다. seaborn jointplot의 단점을 보완합니다. 2.1. seaborn jointplotseaborn API seaborn의 jointplot은 매력적인 기능입니다. 두 변수 각각의 분포와 2차원 분포를 함께 보여줍니다. 각각의 분포는 histogram과 kdeplot으로 표현할 수 있고 2차원 분포는 scatterplot, regression, kdeplot, hexbin등으로 표현할 수 있습니다. 만약 matplotlib에서 일일이 만들어야 한다면 눈물이 앞을 가릴 일입니다. seaborn에서는 단 한 줄로 이런 그림들이 탄생합니다. 2.2. multiple jointplot 그러나 seaborn 만으로는 여러 jointplot이 합쳐진 그림을 표현할 수 없습니다. y축을 공유시키는 것 만으로도 훨씬 기능이 강력해질텐데요. 현실적으로 가장 빠른 방법은 파워포인트입니다. 같은 y축 범위로 그림을 여러 개 그린 후 붙이면 됩니다. 그러나 수작업이 동반되고, 오류 가능성이 커집니다. seaborn과 matplotlib의 힘을 합해서 그려봅시다. 2.3. matplotlib + seaborn 지난 글에서 seaborn과 matplotlib이 섞일 수 있음을 보였습니다. matplotlib으로 틀을 만들고 여기에 seaborn을 삽입합니다. 12345import matplotlib.pyplot as pltimport seaborn as snspenguins = sns.load_dataset(&quot;penguins&quot;) # 펭귄 데이터셋으로 시작합니다.penguins.head() 가로축에 두 개의 데이터 : bill_length_mm, flipper_length_mm, 세로축에 한 개의 데이터 : bill_depth_mm를 놓아보겠습니다. 2.3.1. 축공간 배열 : gridspecmatplotlib.pyplot.subplots matplotlib.gridspec.GridSpec 저는 matplotlib을 객체지향 방식으로 사용할 때 이렇게 합니다. fig, ax = plt.subplots() 명령으로 figure와 axes를 만드는데 가로세로 여러 axes를 만들 때는 ncols, nrows 인자를 사용합니다. 그러나 이렇게 하면 모든 축공간의 크기가 같아집니다. jointplot은 축공간의 크기가 일정하지 않습니다. gridspec을 이용해서 비대칭 축공간을 만듭니다. 12345678910111213fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)]) axs[i].text(0.5, 0.5, f&quot;axs[&#123;i&#125;]&quot;, fontdict=&#123;&quot;horizontalalignment&quot;:&quot;center&quot;, &quot;color&quot;:&quot;gray&quot;&#125;) 축공간은 원래 2차원 배열입니다. 하지만 이를 별로 좋아하지 않아서, dictionary를 사용해 1차원으로 취급합니다. 개인적인 취향입니다. 꼭 따르지 않아도 좋습니다. 2.3.2. 첫 번째 jointplot : scatterplot + kdeplotseaborn.scatterplot seaborn.kdeplot 좌측 하단에 첫 번째 2차원 분포도를 그립니다. x축 변수는 bill_length_nm, y축 변수는 bill_depth_mm로 지정합니다. seaborn 명령의 ax= 인자를 사용해 축공간을 지정합니다. 1234567891011121314151617181920fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]# 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)# 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])# 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])fig.tight_layout() 2.3.3. 첫 번째 jointplot : 1차원 kdeplot 첫 번째 jointplot의 상단과 우측에 1차원 분포도를 그립니다. 두 가지를 주의해야 합니다. 중심이 되는 jointplot과 가로세로 범위를 일치시켜야 합니다. 1차원 분포도의 눈금과 수치는 필요없으니 제거합니다. 123456789101112131415161718192021222324252627282930313233343536373839fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)fig.tight_layout() 2.3.4. 두 번째 jointplot 같은 요령으로 두 번째 분포도 도시합니다. 첫 번째 jointplot에서 x 변수만 바꿔주면 됩니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4])# 3.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel(&#x27;&#x27;)axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)fig.tight_layout() 2.3.5. 부대효과 조정 : spines, grids, 간격 데이터는 모두 올라갔으니 부대 효과를 조정합니다. 불필요한 요소(ex. spines)는 제거하고, 애매한 요소(ex. 위치)는 grid로 명확히 합니다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights, wspace=0.03, hspace=0.03) # setting spaces### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3], zorder=1)# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3], zorder=2)# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False, zorder=1)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False, zorder=1)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 4.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4], zorder=1)# 4.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4], zorder=2)# 4.3. histogram (flipper_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False, zorder=1)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel(&#x27;&#x27;)axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)### 5. unnecessary elements removal# 5.1. upper-right axesaxs[2].axis(&quot;off&quot;)# 5.2. margin kdeplot scale unificationhist_range_max = max(axs[0].get_ylim()[-1], axs[1].get_ylim()[-1], axs[5].get_xlim()[-1])for i in range(len(widths)-1): axs[i].set_ylim(0, hist_range_max)axs[5].set_xlim(0, hist_range_max)# 5.3. redundent labels and titles removalaxs[1].set_yticklabels([])axs[1].set_ylabel(&#x27;&#x27;)axs[4].set_yticklabels([])axs[4].set_ylabel(&#x27;&#x27;)# 5.4. gridsfor i in range(len(heights)*len(widths)): axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0)fig.tight_layout() 1차원 분포의 스케일도 맞춰주었습니다. 그러나 꼭 필요한 작업인지는 의구심이 듭니다. ‘밀도’라는 정의에 맞게 넓이를 1로 만드는 과정이 포함되어 있는데, 이로 인해 x축 스케일이 크면 높이가 낮아지는 경향이 있기 때문입니다. 데이터의 범위에 집중하고 싶다면 스케일을 맞추지 않는 것이 나을지도 모릅니다. 2.3.6. 마무리 작업seaborn tutorial: controlling figure aesthetics 데이터를 표현하는 작업은 사실상 완료되었습니다. 폰트의 크기, 색상 등 가독성을 높입니다. 이 때도 seaborn의 set_style()과 set_context()를 사용하면 편리합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788sns.set_style(&quot;white&quot;)sns.set_context(&quot;talk&quot;)fig = plt.figure(figsize=(14,8))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights, wspace=0.03, hspace=0.03) # setting spaces### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3], zorder=1, legend=False)# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3], zorder=2, legend=False)# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False, zorder=1, fill=True)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False, zorder=1, fill=True)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 4.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4], zorder=1)# 4.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4], zorder=2)# 4.3. histogram (flipper_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False, zorder=1, fill=True)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel(&#x27;&#x27;)axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)### 5. unnecessary elements removal# 5.1. upper-right axesaxs[2].axis(&quot;off&quot;)# 5.2. margin kdeplot scale unificationhist_range_max = max(axs[0].get_ylim()[-1], axs[1].get_ylim()[-1], axs[5].get_xlim()[-1])for i in range(len(widths)-1): axs[i].set_ylim(0, hist_range_max)axs[5].set_xlim(0, hist_range_max)# 5.3. redundent labels and titles removalaxs[1].set_yticklabels([])axs[1].set_ylabel(&#x27;&#x27;)axs[4].set_yticklabels([])axs[4].set_ylabel(&#x27;&#x27;)# 5.4. gridsfor i in range(len(heights)*len(widths)): axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) # 5.5. labelsfont_label = &#123;&quot;color&quot;:&quot;gray&quot;&#125;axs[3].set_xlabel(&quot;Bill Legnth (mm)&quot;, fontdict=font_label, labelpad=12)axs[3].set_ylabel(&quot;Bill Depth (mm)&quot;, fontdict=font_label, labelpad=12)axs[4].set_xlabel(&quot;Flipper Legnth (mm)&quot;, fontdict=font_label, labelpad=12)axs[0].set_ylabel(&quot;Density&quot;, fontdict=font_label, labelpad=12)axs[5].set_xlabel(&quot;Density&quot;, fontdict=font_label, labelpad=12)fig.tight_layout() jointplot의 한계인 2중 jointplot이 구현되었습니다. 2.3.7. generalize : 함수로 만들기 하는 김에, 기능을 일반화합시다. 다중 jointplot 제작 기능을 함수로 만들고, x 변수의 수와 그림 크기, 1차원 분포 스케일 통일 등을 인자로 만듭니다 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163def jointplots(xs, y, data, hue=None, height=6, ratio=5, space=0.2, xlabels=None, ylabel=None, margin_norm=False): &quot;&quot;&quot; ------------------- Input Parameters ------------------- xs : (list or str) feature name(s) of data y : (str) feature name of data data : (pandas.DataFrame) hue : (str) semantic variable that is mapped to determine the color of plot elements. Semantic variable that is mapped to determine the color of plot elements. height : (float) size of the figure ratio : (float) ratio of the joint axes height to marginal axes height. space : (float) space between the joint and marginal axes xlabels : (list or str) xlabels ylabel : (str) ylabel margin_norm : (boolean) if True, kdeplots at marginal axes have same scale. &quot;&quot;&quot; ### 1. input check # input type assert isinstance(xs, list) or isinstance(xs, str) if isinstance(xs, list): assert all([isinstance(x, str) for x in xs]) else: xs = [xs] if xlabels != None: assert isinstance(xlabels, list) or isinstance(xlabels, str) if isinstance(xlabels, list): assert all([isinstance(xlabel, str) for xlabel in xlabels]) else: xlabels = [xlabels] if ylabel != None: assert isinstance(ylabel, str) if hue != None: assert isinstance(hue, str) # input data assert all([x in data.columns for x in xs]) assert y in data.columns if hue != None: assert hue in data.columns ### 2. figure h_margin = height / (ratio + 1) h_joint = height - h_margin if isinstance(xs, list): n_x = len(xs) else: n_x = 1 widths = [h_joint] * n_x + [h_margin] heights = [h_margin, h_joint] ncols = len(widths) nrows = len(heights) fig = plt.figure(figsize=(sum(widths), sum(heights))) ### 3. gridspec preparation spec = fig.add_gridspec(ncols=ncols, nrows=nrows, width_ratios = widths, height_ratios = heights, wspace=space, hspace=space ) ### 4. setting axes axs = &#123;&#125; for i in range(ncols * nrows): axs[i] = fig.add_subplot(spec[i//ncols, i%ncols]) ### 5. jointplots (scatterplot + kdeplot) for i, x in enumerate(xs, ncols): if i == ncols: legend=True else: legend=False sns.kdeplot(x=x, y=y, data=data, hue=hue, alpha=0.3, ax=axs[i], zorder=2, legend=False) sns.scatterplot(x=x, y=y, data=data, hue=hue, alpha=0.8, ax=axs[i], zorder=3, legend=legend) ### 6. kdeplots at marginal axes axs[ncols-1].axis(&quot;off&quot;) axes_mx = list(range(ncols-1)) axes_my = 2*ncols - 1 for i, x in zip(axes_mx, xs): sns.kdeplot(x=x, data=data, hue=hue, fill=True, ax=axs[i], zorder=2, legend=False) axs[i].set_xlim(axs[i+ncols].get_xlim()) axs[i].set_xlabel(&quot;&quot;) axs[i].set_xticklabels([]) axs[i].spines[&quot;left&quot;].set_visible(False) axs[i].spines[&quot;top&quot;].set_visible(False) axs[i].spines[&quot;right&quot;].set_visible(False) sns.kdeplot(y=y, data=data, hue=hue, fill=True, ax=axs[axes_my], zorder=2, legend=False) axs[axes_my].set_ylim(axs[ncols].get_ylim()) axs[axes_my].set_ylabel(&quot;&quot;) axs[axes_my].set_yticklabels([]) axs[axes_my].spines[&quot;bottom&quot;].set_visible(False) axs[axes_my].spines[&quot;top&quot;].set_visible(False) axs[axes_my].spines[&quot;right&quot;].set_visible(False) if margin_norm == True: hist_range_max = max([axs[m].get_ylim()[-1] for m in axes_mx] + [axs[axes_my].get_xlim()[-1]]) for i in axes_mx: axs[i].set_ylim(0, hist_range_max) axs[axes_my].set_xlim(0, hist_range_max) ### 7. unnecessary elements removal # 7.1. labels and ticklabels axes_j = list(range(ncols, 2*ncols-1)) for i in axes_j: if i != ncols: axs[i].set_ylabel(&quot;&quot;) axs[i].set_yticklabels([]) # 7.2. marginal axes for i in axes_mx: if i != 0: axs[i].set_ylabel(&quot;&quot;) axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) axs[i].set_yticklabels([]) yticks = axs[i].get_yticks() ylim = axs[i].get_ylim() for ytick in yticks: if 0 &lt; ytick &lt; ylim[-1]: axs[i].text(axs[i].get_xlim()[0], ytick, str(ytick), fontdict=&#123;&quot;verticalalignment&quot;:&quot;center&quot;&#125;) axs[axes_my].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) axs[axes_my].set_xticklabels([]) axes_my_xticks = axs[axes_my].get_xticks() axes_my_xlim = axs[axes_my].get_xlim() for xtick in axes_my_xticks: if 0 &lt; xtick &lt; axes_my_xlim[-1]: axs[axes_my].text(xtick, axs[axes_my].get_ylim()[0], str(xtick), rotation=270, fontdict=&#123;&quot;horizontalalignment&quot;:&quot;center&quot;&#125;) # 7.3. labels font_label = &#123;&quot;color&quot;: &quot;gray&quot;, &quot;fontsize&quot;:&quot;large&quot;&#125; labelpad = 12 for i, x in zip(axes_j, xlabels): axs[i].set_xlabel(x, fontdict=font_label, labelpad=labelpad) if i == ncols: axs[i].set_ylabel(ylabel, fontdict=font_label, labelpad=labelpad) axs[0].set_ylabel(&quot;Density&quot;, fontdict=font_label, labelpad=labelpad) axs[2*ncols-1].set_xlabel(&quot;Density&quot;, fontdict=font_label, labelpad=labelpad) fig.align_ylabels([axs[0], axs[ncols]]) fig.align_xlabels([axs[x] for x in range(ncols, 2*ncols)]) plt.tight_layout() return fig, axs X인자의 수가 바뀌어도 jointplot이 안정적으로 그려집니다. 1차원 분포도 표현 방식을 바꾸어 전보다 깔끔해졌습니다. 123jointplots([&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, &quot;flipper_length_mm&quot;], &quot;body_mass_g&quot;, penguins, hue=&quot;species&quot;, height=8, ratio=5, space=0.03, xlabels=[&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, &quot;Flipper Length (mm)&quot;], ylabel=&quot;Body Mass (g)&quot;) 2.4. 결론 seaborn의 jointplot을 가져다 쓰는 데 그치지 않았습니다. matplotlib의 객체지향 방식을 이용해 seaborn의 한계를 벗어날 수 있었습니다. 본 예제에서는 scatterplot과 2차원 kdeplot만 결합했습니다. 그러나 이 외에도 seaborn과 matplotlib이 제공하는 거의 모든 기능을 결합할 수 있습니다. 매뉴얼의 한계에 얽매이지 말고 상상력을 동원해 보시면 어떨까요. 출저: https://jehyunlee.github.io/2020/10/03/Python-DS-35-seaborn_matplotlib2/","categories":[],"tags":[]},{"title":"Seaborn with Matplotlib (1)","slug":"Seaborn_with_Matplotlib_1","date":"2020-11-02T05:41:57.603Z","updated":"2020-11-02T06:26:22.434Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_1/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_1/","excerpt":"","text":"1. seaborn + matplotlib seaborn을 matplotlib과 섞어쓰는 방법입니다. 4부 중 첫 번째 시간입니다. seaborn 함수 중 matplotlib axes를 반환하는 함수들에 관한 내용입니다. seaborn API seaborn은 matplotlib을 쉽고 아름답게 쓰고자 만들어졌습니다. 따라서 seaborn의 결과물은 당연히 matplotlib의 결과물입니다. 그러나 간혹 seaborn이 그린 그림의 폰트, 색상에 접근이 되지 않아 난처합니다. seaborn의 구조를 잘 이해하지 못하면 해결도 어렵습니다. v0.11 기준으로 seaborn에는 다음 함수들이 있습니다. matplotlib의 출력물은 figure와 axes만을 반환합니다. seaborn의 명령어 중 axes를 반환하는 것들은 matplotlib과 섞어 쓰기 좋습니다. 먼저 matplotlib의 객체 지향object oriented interface를 사용해서 그림의 틀을 만든 뒤, 특정 axes에 seaborn을 삽입하면 됩니다. 결론적으로, 하고 싶은 거 다 됩니다. 1.1. Load data 예제로 사용할 펭귄 데이터를 불러옵니다. seaborn에 내장되어 있습니다.123456import pandas as pdimport matplotlib.pyplot as pltimport seaborn as snspenguins = sns.load_dataset(&quot;penguins&quot;)penguins.head() 1.2. figure and axes matplotlib으로 도화지figure를 깔고 축공간axes를 만듭니다. 1 x 2 축공간을 구성합니다. 123fig, axes = plt.subplots(ncols=2, figsize=(8,4))fig.tight_layout() 1.3. plot with matplotlib matplotlib 기능을 이용해서 산점도를 그립니다. x축은 부리 길이 bill length y축은 부리 위 아래 두께 bill depth 색상은 종species로 합니다. Adelie, Chinstrap, Gentoo이 있습니다. 두 축공간 중 왼쪽에만 그립니다. 123456789101112131415fig, axes = plt.subplots(ncols=2, figsize=(8, 4))species_u = penguins[&quot;species&quot;].unique()# plot 0 : matplotlibfor i, s in enumerate(species_u): axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C&#123;i&#125;&quot;, label=s, alpha=0.3 )axes[0].legend(species_u, title=&quot;species&quot;)axes[0].set_xlabel(&quot;Bill Length (mm)&quot;)axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;)fig.tight_layout() 1.4. plot with seabornseaborn scatterplot 이번엔 같은 plot을 seaborn으로 그려봅니다. 위 코드에 아래 세 줄만 추가합니다. 1234# plot 1 : seabornsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1])axes[1].set_xlabel(&quot;Bill Length (mm)&quot;)axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;) 세 줄로 거의 동일한 그림이 나왔습니다. scatter plot의 점 크기만 살짝 작습니다. label의 투명도만 살짝 다릅니다. seaborn 명령 scatterplot()을 그대로 사용했습니다. x축과 y축 label도 바꾸었습니다. ax=axes[1] 인자에서 볼 수 있듯, 존재하는 axes에 그림만 얹었습니다. matplotlib 틀 + seaborn 그림 이므로, matplotlib 명령이 모두 통합니다. 1.5. matplotlib + seaborn &amp; seaborn + matplotlib matplotlib과 seaborn이 자유롭게 섞일 수 있습니다. matplotlib 산점도 위에 seaborn 추세선을 얹을 수 있고, seaborn 산점도 위에 matplotlib 중심점을 얹을 수 있습니다. 파이썬 코드는 다음과 같습니다. 12345678910111213141516171819202122232425262728293031323334fig, axes = plt.subplots(ncols=2, figsize=(8, 4))species_u = penguins[&quot;species&quot;].unique()# plot 0 : matplotlib + seabornfor i, s in enumerate(species_u): # matplotlib 산점도 axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C&#123;i&#125;&quot;, label=s, alpha=0.3 ) # seaborn 추세선 sns.regplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins.loc[penguins[&quot;species&quot;]==s], scatter=False, ax=axes[0]) axes[0].legend(species_u, title=&quot;species&quot;)axes[0].set_xlabel(&quot;Bill Length (mm)&quot;)axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;)# plot 1 : seaborn + matplotlib# seaborn 산점도sns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1])axes[1].set_xlabel(&quot;Bill Length (mm)&quot;)axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;)for i, s in enumerate(species_u): # matplotlib 중심점 axes[1].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), c=f&quot;C&#123;i&#125;&quot;, alpha=1, marker=&quot;x&quot;, s=100 )fig.tight_layout() 1.6. seaborn + seaborn + matplotlib 안 될 이유가 없습니다. seaborn scatterplot + seaborn kdeplot + matplotlib text입니다. 1234567891011121314151617181920fig, ax = plt.subplots(figsize=(6,5))# plot 0: scatter plotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, color=&quot;k&quot;, data=penguins, alpha=0.3, ax=ax, legend=False)# plot 1: kde plotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.5, ax=ax, legend=False)# text:species_u = penguins[&quot;species&quot;].unique()for i, s in enumerate(species_u): ax.text(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), s = s, fontdict=&#123;&quot;fontsize&quot;:14, &quot;fontweight&quot;:&quot;bold&quot;,&quot;color&quot;:&quot;k&quot;&#125; )ax.set_xlabel(&quot;Bill Length (mm)&quot;)ax.set_ylabel(&quot;Bill Depth (mm)&quot;)fig.tight_layout() 1.7. 결론 seaborn을 matplotlib과 마음껏 섞어쓰세요 단, axes를 반환하는 명령어에 한해서 말입니다. 이런 명령어를 axes-level function 이라고 합니다. 출저: https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/","categories":[],"tags":[]},{"title":"","slug":"text","date":"2020-10-28T14:00:42.566Z","updated":"2020-10-28T14:00:42.616Z","comments":true,"path":"2020/10/28/text/","link":"","permalink":"https://kdmid.github.io/2020/10/28/text/","excerpt":"","text":"text /*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=\"1.11.3\",m=function(a,b){return new m.fn.init(a,b)},n=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,o=/^-ms-/,p=/-([\\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:\"jQuery\"+(l+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===m.type(a)},isArray:Array.isArray||function(a){return\"array\"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,\"constructor\")&&!j.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,\"ms-\").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(n,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function r(a){var b=\"length\"in a&&a.length,c=m.type(a);return\"function\"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1","categories":[],"tags":[]}],"categories":[],"tags":[]}