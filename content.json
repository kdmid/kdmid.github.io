{"meta":{"title":"hello","subtitle":"","description":"","author":"Deukjung","url":"https://kdmid.github.io","root":"/"},"pages":[],"posts":[{"title":"Seaborn with Matplotlib (4)","slug":"Seaborn_with_Matplotlib_4","date":"2020-11-02T13:35:55.612Z","updated":"2020-11-03T14:28:52.462Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_4/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_4/","excerpt":"","text":"4. seaborn figure-level 다듬기 seaborn + matplotlib 마지막 시간입니다. figure-level 그림을 그리고 다듬어 봅니다. 자체적으로 지원하는 명령어를 사용해보고, 개흉 심장마사지 방법을 알아보겠습니다. seaborn API seaborn tutorial 4.1. figure-level으로 편리하게 그리기: pairplot()wikipedia: Exploratory data analysis wikipedia: Anscombe’s quartet autodesk: datasaurus seaborn.pairplot EDA에서 피할 수 없는 과정이 상관도입니다. 두 변수 사이의 관계를 그려 관계를 파악합니다. 대개 산점도scatter plot나 밀도 함수density plot를 쓰고, 추세선regression을 덧붙이는 경우도 있습니다. 데이터 분포는 통계값으로만 확인하면 안됩니다. 평균과 표준편차는 같은데 분포는 다른 경우가 많습니다. 반드시 분포를 그려 봐야 합니다. Anscombe’s quartet이 아주 좋은 예시입니다. N개의 인자 사이에는 \\(N(N−1)/2\\)가지 관계가 있습니다. seaborn의 pairplot()은 여러 인자 사이의 수많은 상관도를 쉽게 그려줍니다. 붓꽃iris 데이터셋으로 상관도를 그려봅니다. 꽃받침sepal과 꽃잎petal, 길이length와 폭width 네 가지 인자로부터 여섯 가지의 상관도, 네 가지의 히스토그램이 나옵니다. 코드 한 줄로 그려봅시다. 123import seaborn as snsiris = sns.load_dataset(&quot;iris&quot;) 종species별 분포를 그려봅니다. 1g = sns.pairplot(iris, hue=&quot;species&quot;) hue=라는 인자 하나만 추가했을 뿐입니다. 그림이 갑자기 예뻐졌습니다. 히스토그램도 밀도함수로 바뀌어서 훨씬 보기 좋습니다. 여기에 다른 그림을 겹쳐보겠습니다. 대각선 위 : 2차원 밀도함수 + 추세선 대각선 아래 : 2차원 밀도함수 + 산포도 seaborn figure-level 기능만으로 가능합니다. .map_lower()와 .map_upper를 사용합니다. 123g = sns.pairplot(iris, hue=&quot;species&quot;, kind=&quot;kde&quot;, plot_kws=&#123;&quot;alpha&quot;:0.3&#125;)g.map_lower(sns.scatterplot)g.map_upper(sns.regplot, scatter=False, truncate=False, ci=False) map_lower()와 map_upper()는 대각선의 위와 아래에 그림을 덧씌우는map 함수입니다. 앞서 완성한 pairplot에 새로운 그림을 덧붙입니다. 인자로는 함수 이름과 이 함수의 옵션들을 연달아 넣어 줍니다. 함수에 맞는 인자를 넣어줘야 합니다. 4.2. figure-level 그림 뼈대부터 세우기: PairGrid()seaborn.PairGrid pairplot을 단계별로 그리는 방법입니다. 코드 양은 pairplot()한 줄보다 늘어납니다. 그러나 자유도가 늘어납니다. .pairplot() 으로는 위 아래를 완전히 다르게 할 수 없습니다. 대각선의 아래엔 산점도와 추세선을 그리고 대각선 위에는 밀도함수만 그려보겠습니다. 123456789101112131415# 틀 만들기g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False)# diagonalg.map_diag(sns.kdeplot, fill=True)# lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)# upperg.map_upper(sns.kdeplot, alpha=0.3)# legendg.add_legend() .pairplot()과 같은 형식의 그림이 나왔습니다. 내 의도를 더 잘 반영할 수 있게 되었습니다. 8번째 줄에는 plt.scatter가 들어가 있습니다. .pairplot()도 마찬가지지만 .map()에는 seaborn대신 matplotlib - 함수를 사용할 수 있습니다. 중복되는 오른쪽 윗부분을 생략할 수 있습니다. corner=True를 넣어줍니다. 123456789101112g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)# lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendg.add_legend() 이제 작은 수정을 해봅니다. 대각선에 사각 테두리 치기 범례를 그림 안으로 가져오기 가슴을 열고 심장마사지를 할 시간입니다. 4.3. figure-level 그림 객체 접근seaborn.FacetGrid matplotlib.figure.Figure matplotlib.axes.Axes matplolib 그림은 figure와 axes로 나뉩니다. seaborn 그림도 결국 matplotlib 그림입니다. seaborn의 figure와 axes에 접근하면 됩니다. 4.3.1. axes: .axes 이전 글에서 axes를 이용해 jointplot을 재현했습니다. axes 객체는 .axes를 이용해 접근 가능합니다. 1g.axes 확인 결과 AxesSubplot의 array입니다. 4.3.1.1. 특정 axes 윤곽선 그리기Seaborn with Matplotlib (2) Spines &amp; Grids 정체를 알았으니 axes[i][j]로 접근할 수 있습니다. g.axes[i][j]의 spine을 보이게 합니다. 12345678910111213141516g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)for i in range(4): g.axes[i][i].spines[&quot;left&quot;].set_visible(True) g.axes[i][i].spines[&quot;top&quot;].set_visible(True) g.axes[i][i].spines[&quot;right&quot;].set_visible(True) # lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendg.add_legend() 4.3.1.2. 범례 조정seaborn axisgrid.py 소스코드 matplotlib.axes.Axes.get_legend_handles_labels matplotlib.axes.Axes.legend legend 정보를 가져와서 legend로 삽입합니다. 대개 legend에 필요한 handles와 labels는 .get_legend_handles_labels()로 가져옵니다. 하지만 seaborn figure-level 그림엔 이 명령이 통하지 않습니다. private처럼 보이는 ._legend_data를 사용합니다. 공식 문서에 없습니다. 소스 코드를 뒤적여야 합니다. ._legend_data 정체를 확인합니다. 범례가 dict 형식으로 들어 있습니다. 1g._legend_data 아래 코드를 추가하여 범례를 이동합니다. 12345678handles = g._legend_data.values()labels = g._legend_data.keys()# axes[1][0] 기준으로 오른쪽 멀리 범례 삽입g.axes[1][0].legend(handles=handles, labels=labels, bbox_to_anchor=(3.45, 1), fontsize=&quot;large&quot;, frameon=False ) 이런 방식으로 특정 axes만 제어할 수 있습니다. 원하는 그림, 글자을 넣을 수 있고 특정 데이터의 색상을 변경할 수 있습니다. 4.3.2. figure: .fig 개별 공간은 axes로 제어하지만 여러 axes가 연관된 공간은 figure로 제어합니다. figure 객체는 .fig를 이용해 접근 가능합니다 1type(g.fig) type()으로 감싸주지 않으면 그림이 통으로 출력됩니다. 4.3.2.1. ylabel alignmentmatplolib.figure.Figure #align_ylabels matplotlib Align y-labels 위 그림에서 ylabel 줄이 잘 맞지 않습니다. 맨 왼쪽 아래 axes[3][0]의 label이 비죽 나왔네요. 다른 ylabel을 움직여서 열을 맞춰 봅시다. 위 그림 코드의 맨 마지막 줄에 한 줄만 추가합니다 1g.fig.align_ylabels(g.axes[:,0]) 4.3.2.2. 범례 조정matplolib.figure.Figure #legend 범례는 figure 기준으로도 삽입 가능합니다. 아래 코드는 위의 axes[1][0].legend()와 동일합니다. 전체적인 그림의 위치를 잡을 수 있어 더 좋습니다. 123g.fig.legend(handles=handles, labels=labels, bbox_to_anchor=(0.75, 0.75), fontsize=&quot;large&quot;) 4.3.2.3. suptitlematplolib.figure.Figure #suptitle 그림 전체에 제목을 붙일 수 있습니다. 1234g.fig.suptitle(&quot;iris dataset&quot;, y=1.01, weight=&quot;bold&quot;, fontsize=&quot;x-large&quot; )g.fig.tight_layout() 4.3.2.4. facecolor, edgecolormatplolib.figure.Figure #set_facecolor 그림 바탕색을 칠합니다. 1g.fig.set_facecolor(&quot;whitesmoke&quot;) 4.3.3. 최종 x, ylabel까지 정리하면 이렇습니다. 123456789101112131415161718192021222324252627282930313233343536373839g = sns.PairGrid(iris, hue=&quot;species&quot;, diag_sharey=False, corner=True)# diagonalg.map_diag(sns.kdeplot, fill=True)for i in range(4): g.axes[i][i].spines[&quot;left&quot;].set_visible(True) g.axes[i][i].spines[&quot;top&quot;].set_visible(True) g.axes[i][i].spines[&quot;right&quot;].set_visible(True) # lowerg.map_lower(plt.scatter, s=30, edgecolor=&quot;w&quot;)g.map_lower(sns.regplot, scatter=False, truncate=False, ci=False)g.map_lower(sns.kdeplot, alpha=0.3)# legendhandles = g._legend_data.values()labels = g._legend_data.keys()g.fig.legend(handles=handles, labels=labels, bbox_to_anchor=(0.75, 0.75), fontsize=&quot;large&quot;)# x, y labelslabels = [&quot;Sepal Length&quot;, &quot;Sepal Width&quot;, &quot;Petal Length&quot;, &quot;Petal Width&quot;]font_labels = &#123;&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;&#125;for i in range(4): g.axes[3, i].set_xlabel(labels[i], fontdict=font_labels) g.axes[i, 0].set_ylabel(labels[i], fontdict=font_labels)# ylabel alignmentg.fig.align_ylabels(g.axes[:,0])# suptitleg.fig.suptitle(&quot;iris dataset&quot;, y=1.01, weight=&quot;bold&quot;, fontsize=&quot;x-large&quot; )g.fig.tight_layout()# facecolorg.fig.set_facecolor(&quot;whitesmoke&quot;) 5. 결론 네 편의 글에 걸쳐 matplotlib + seaborn 연계기를 정리했습니다. 개별적인 코드와 기술보다는 본질에 집중합시다. figure와 axes를 통하면 웬만한건 다 된다는 겁니다. 0.11에서 seaborn의 공식문서가 대폭 정리됐습니다. 하지만 아직 부족한 점이 많습니다. 특히 많은 경우 matplotlib에 숙달되었다고 전제합니다. 일단 matplotlib부터 제대로 익혀봅시다. 출저: https://jehyunlee.github.io/2020/10/10/Python-DS-37-seaborn_matplotlib4/","categories":[],"tags":[]},{"title":"Seaborn with Matplotlib (3)","slug":"Seaborn_with_Matplotlib_3","date":"2020-11-02T12:29:11.750Z","updated":"2020-11-02T14:37:11.816Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_3/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_3/","excerpt":"","text":"3. seaborn figure-level function seaborn의 핵심기능, 강력한 명령입니다. 4부 중 세 번째 시간입니다. matplotlib으로는 매우 수고스러울 일을 줄여줍니다. 그러나 손대기 어렵기도 합니다. 이유와 해결방법을 알아봅시다. seaborn API seaborn tutorial seaborn with matplotlib (1) 지난 글에서 matplotlib과 친한 함수를 알아봤습니다. 이런 axex 반환 함수를 axes-level 함수, 반대로 그림 전체를 반환하는 함수를 figure-level 함수라고 합니다. 아래 노란 부분이 figure-level 함수입니다. 반환 형식return type이 왜 이렇게 깔끔하지 않은지는 뒤에 보겠습니다. figure-level 함수는 복잡한 그림을 한 번에 편하게 그려줍니다. 3.1. figure-level 편리함 맛보기: FacetGrid() seaborn에 내장된 penguins dataset에는 이런 데이터가 있습니다. bill_length_mm : 부리 길이 bill_depth_mm : 부리 위아래 두께 species : 펭귄 종 sex : 성별 island : 서식지 이 데이터를 산점도로 한번에 나타내고자 합니다. X축 : bill_length_mm Y축 : bill_depth_mm 색상 : species X방향 axes : island Y방향 axes : sex matplotlib 코드는 이렇습니다. 12345678910111213141516171819202122232425262728293031fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(12, 8), sharex=True, sharey=True)# 인자별 데이터 종 수 세기sex = penguins[&quot;sex&quot;].dropna().unique()island = penguins[&quot;island&quot;].dropna().unique()species = penguins[&quot;species&quot;].dropna().unique()# X방향 axes: sexfor i in range(len(sex)): # Y방향 axes: island for j in range(len(island)): # 색상 : species for k in range(len(species)): try: axes[i][j].scatter(penguins.loc[penguins[&quot;sex&quot;] == sex[i]].loc[penguins[&quot;island&quot;] == island[j]].loc[penguins[&quot;species&quot;] == species[k]][&quot;bill_length_mm&quot;], penguins.loc[penguins[&quot;sex&quot;] == sex[i]].loc[penguins[&quot;island&quot;] == island[j]].loc[penguins[&quot;species&quot;] == species[k]][&quot;bill_depth_mm&quot;]) axes[i][j].set_title(f&quot;sex = &#123;sex[i]&#125; | island = &#123;island[j]&#125;&quot;) except: # 결측치 예외처리 pass # 맨 아래줄에만 xlabel 추가 axes[len(sex)-1, j].set_xlabel(&quot;bill_length_mm&quot;) # 맨 왼쪽에만 ylabel 추가 axes[i, 0].set_ylabel(&quot;bill_depth_mm&quot;)# 그래프 우측에 범례 표시fig.legend(species, title=&quot;species&quot;, bbox_to_anchor=(0.95, 0.5))# 그래프 간격 조정fig.tight_layout(rect=[0,0,0.85,1]) 따로 꾸민 것도 없는데 매우 번잡합니다. 인자별로 몇가지인지를 알아내야 합니다. 결측치 처리가 필요합니다. 안하면 에러납니다. 색상별로 따로 그려야 합니다. 그런데 seaborn을 사용하면 세 줄 만에 끝납니다. 123g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.scatterplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;)g.add_legend() FacetGrid()로 만든 공간을 .map()으로 채웁니다. 데이터셋 이름, 변수 이름, 그리는 방식 외에 다른 내용이 없습니다. 인자가 여럿인 관계를 보기에 아주 좋습니다. 밀도 함수density plot로 바꾸는 것도 간단합니다. 위 코드에서 sns.scatterplot만 sns.kdeplot으로 넣으면 됩니다. 123g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;)g.add_legend() figure-level 함수는 복잡한 그림을 간단히 그릴 때 매우 강력합니다. 이 그림들을 matplotlib으로 그리려면 얼마나 막막할까요. 3.2. figure-level 꾸미기: FacetGrid()seaborn.FacetGrid seaborn.kdeplot seaborn.regplot 이번엔 figure-level 그림을 꾸며 보겠습니다. kdeplot위에 추세선을 겹쳐 그립니다. 추세선이 중간에 안끊기면 좋겠습니다. 신뢰구간은 80% 수준으로 그리고 싶습니다. xlabel을 “Bill Length (mm)”로 바꾸고 ylabel을 “Bill Depth (mm)”로 바꿉니다. 공식 홈페이지의 설명에 힘입어 해냈습니다. 123456g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;)g.add_legend() 한 단계 더 꾸며보도록 합시다. xlabel, ylabel 글자를 키우고 싶습니다. 추세선의 신뢰구간 80%를 적어두고 싶습니다. axes마다 붙어 있는 title을 정리하고 싶습니다. 첫 단계에서 막혔습니다 xlabel, ylabel을 수정할 때 set_axis_labels()를 사용했습니다. 공식 홈페이지의 FacetGrid()부분 가이드를 따른 것입니다. 그런데 set_axis_labels()에 대한 설명이 더 이상 없습니다. 혹시나, matplotlib 명령어를 넣어봅니다. fontdict=를 적용합니다 1234567g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, fontdict=&#123;&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;&#125;)g.add_legend() figure-level 그림의 세부 설정은 도움말 찾기도 어렵습니다. 매뉴얼에 없는 내용을 상상해서 넣어야 합니다. 아직은 공식 홈페이지가 충만하지 않습니다. 소스코드를 뜯어봐서 기능을 확인하거나 matplotlib 명령어를 숙지하고 대응시켜 시도해야 합니다. 3.3. figure-level의 장단점 공식 튜토리얼에 정리된 장단점은 이렇습니다 하나씩 짚어보겠습니다. (1) 데이터 변수에 따른 축공간 생성 matplotlib에서 변수 갯수를 세어야 했던 것에 비해서 편리합니다. seaborn에 구현된 그림을 제어하는 인자 수가 확실히 적습니다. 번거롭더라도 axes에 직접 접근해서 matplotlib 명령을 쓰는 게 낫습니다. (2) 그림 밖 범례 생성 그림 밖에 붙는 것은 다행입니다. 그러나 통제가 안되어 심각한 갈증을 유발합니다. (3) figure-level 수정 &amp; (4) figure size를 조정하는 인자가 다름 장점보다 단점이 크다고 생각됩니다. 더 쉬운 명령어를 제공한다고 해도 결국은 또 다른 문법입니다. matplotlib 명령어만 해도 정신이 없는데 말이죠. 지금까지의 경험으로 이런 결론이 나옵니다. “figure-level의 가성비는 그리자마자, 손을 더 대기 전이 가장 높다.” 새로운 명령어는 새로운 혼돈입니다. 시각화만 붙잡고 있을 게 아니라 통계분석, 머신러닝도 해야 하거든요. 3.4. figure-level그림이 손대기 어려운 이유github: seaborn source code seaborn 코드를 뜯어보면 클래스 구조는 이렇습니다. multi-plot grids는 Grid 클래스를 상속받는 가족입니다. FacetGrid(), PairGrid(), ClusterGrid 입니다. JointGrid()는 Grid를 상속받지 않습니다. Grid로 만든 공간에 목적에 맞는 그림을 채웁니다. relplot(), displot(), catplot(), lmplot()은 1x1 FacetGrid()로 출력됩니다. 그리고 Grid 클래스는 **figure**의 wrapper입니다. 정확히는 matplotlib.pyplot.subplots()의 wrapper입니다. 따라서 figure, axes에 적용되는 matplotlib 명령이 안통합니다. 그래서 set_axis_labels같은 자체 명령어를 탑재하고 있습니다. 하지만 보셨다시피 도움말이 충분치 않습니다. 3.5. figure-level 그림을 꾸미는 방법Doctor! The heart’s stopped! 한마디로, seaborn 제공 함수는 한계가 큽니다. 기능 자체도 많이 빠져있고 있는 기능도 문서화가 덜 됐습니다. 이걸 믿고 쓰긴 어렵습니다. 하지만 대안이 있습니다. seaborn 그림을 matplotlib 그림으로 간주합니다. figure-level 객체 안으로 한 걸음 들어갑니다. 그리고 figure와 axes를 직접 건드립니다. 개흉 심장마사지를 상상하시면 됩니다. 가슴을 열고 직접 심장을 마사지하는 겁니다. 그러면, 풀지 못했던 난제도 이렇게 풀립니다. 1234567891011121314151617181920212223242526272829g = sns.FacetGrid(penguins, row=&quot;sex&quot;, col=&quot;island&quot;, hue=&quot;species&quot;, margin_titles=True, despine=False)g.map(sns.kdeplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, alpha=0.3)g.map(sns.regplot, &quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, truncate=False, ci=80, scatter=False)g.add_legend()# xlabel, ylabel 수정g.set_axis_labels(&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, fontdict=&#123;&quot;fontsize&quot;:&quot;large&quot;, &quot;color&quot;:&quot;gray&quot;, &quot;fontweight&quot;:&quot;bold&quot;&#125;)# axes 직접 접근, 1차원 행렬로 표현axs = g.axes.ravel()for i, ax in enumerate(axs): # 열 title 수정 if i &lt; 3: ax.set_title(ax.get_title(), fontdict=&#123;&quot;fontsize&quot;:&quot;x-large&quot;, &quot;color&quot;:&quot;k&quot;&#125;, pad=12) # 행 title 수정 if i%3 == 2: sex = &quot;Male&quot; if i == 2 else &quot;Female&quot; ax.texts.clear() text = ax.annotate(f&quot;sex = &#123;sex&#125;&quot;, xy=(1.02, .5), xycoords=&quot;axes fraction&quot;, rotation=270, ha=&quot;left&quot;, va=&quot;center&quot;, fontsize=&quot;x-large&quot;, color=&quot;k&quot;)# suptitle 추가g.fig.suptitle(&quot;Penguins dataset summary (ci = 80%) &quot;, fontsize=&quot;xx-large&quot;, fontweight=&quot;bold&quot;, color=&quot;indigo&quot;)# 전반적 크기 조정 g.fig.tight_layout(rect=[0,0,0.88,0.97]) 외웁시다. figure-level 함수는 matplotlib과 못 섞는다. figure-level 함수는 figure와 axes를 한번 더 감싸고 있다. figure-level 함수를 수정하려면 후벼 파는 과정이 필요하다. 출저: https://jehyunlee.github.io/2020/10/06/Python-DS-36-seaborn_matplotlib3/","categories":[],"tags":[]},{"title":"Seaborn with Matplotlib (2)","slug":"Seaborn_with_Matplotlib_2","date":"2020-11-02T06:27:20.705Z","updated":"2020-11-02T07:02:20.062Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_2/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_2/","excerpt":"","text":"2. seaborn + matplotlib을 이용한 jointplot 보완 seaborn을 matplotlib과 섞어쓰는 방법입니다. 4부 중 두 번째 시간입니다. seaborn jointplot의 단점을 보완합니다. 2.1. seaborn jointplotseaborn API seaborn의 jointplot은 매력적인 기능입니다. 두 변수 각각의 분포와 2차원 분포를 함께 보여줍니다. 각각의 분포는 histogram과 kdeplot으로 표현할 수 있고 2차원 분포는 scatterplot, regression, kdeplot, hexbin등으로 표현할 수 있습니다. 만약 matplotlib에서 일일이 만들어야 한다면 눈물이 앞을 가릴 일입니다. seaborn에서는 단 한 줄로 이런 그림들이 탄생합니다. 2.2. multiple jointplot 그러나 seaborn 만으로는 여러 jointplot이 합쳐진 그림을 표현할 수 없습니다. y축을 공유시키는 것 만으로도 훨씬 기능이 강력해질텐데요. 현실적으로 가장 빠른 방법은 파워포인트입니다. 같은 y축 범위로 그림을 여러 개 그린 후 붙이면 됩니다. 그러나 수작업이 동반되고, 오류 가능성이 커집니다. seaborn과 matplotlib의 힘을 합해서 그려봅시다. 2.3. matplotlib + seaborn 지난 글에서 seaborn과 matplotlib이 섞일 수 있음을 보였습니다. matplotlib으로 틀을 만들고 여기에 seaborn을 삽입합니다. 12345import matplotlib.pyplot as pltimport seaborn as snspenguins = sns.load_dataset(&quot;penguins&quot;) # 펭귄 데이터셋으로 시작합니다.penguins.head() 가로축에 두 개의 데이터 : bill_length_mm, flipper_length_mm, 세로축에 한 개의 데이터 : bill_depth_mm를 놓아보겠습니다. 2.3.1. 축공간 배열 : gridspecmatplotlib.pyplot.subplots matplotlib.gridspec.GridSpec 저는 matplotlib을 객체지향 방식으로 사용할 때 이렇게 합니다. fig, ax = plt.subplots() 명령으로 figure와 axes를 만드는데 가로세로 여러 axes를 만들 때는 ncols, nrows 인자를 사용합니다. 그러나 이렇게 하면 모든 축공간의 크기가 같아집니다. jointplot은 축공간의 크기가 일정하지 않습니다. gridspec을 이용해서 비대칭 축공간을 만듭니다. 12345678910111213fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)]) axs[i].text(0.5, 0.5, f&quot;axs[&#123;i&#125;]&quot;, fontdict=&#123;&quot;horizontalalignment&quot;:&quot;center&quot;, &quot;color&quot;:&quot;gray&quot;&#125;) 축공간은 원래 2차원 배열입니다. 하지만 이를 별로 좋아하지 않아서, dictionary를 사용해 1차원으로 취급합니다. 개인적인 취향입니다. 꼭 따르지 않아도 좋습니다. 2.3.2. 첫 번째 jointplot : scatterplot + kdeplotseaborn.scatterplot seaborn.kdeplot 좌측 하단에 첫 번째 2차원 분포도를 그립니다. x축 변수는 bill_length_nm, y축 변수는 bill_depth_mm로 지정합니다. seaborn 명령의 ax= 인자를 사용해 축공간을 지정합니다. 1234567891011121314151617181920fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]# 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)# 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])# 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])fig.tight_layout() 2.3.3. 첫 번째 jointplot : 1차원 kdeplot 첫 번째 jointplot의 상단과 우측에 1차원 분포도를 그립니다. 두 가지를 주의해야 합니다. 중심이 되는 jointplot과 가로세로 범위를 일치시켜야 합니다. 1차원 분포도의 눈금과 수치는 필요없으니 제거합니다. 123456789101112131415161718192021222324252627282930313233343536373839fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)fig.tight_layout() 2.3.4. 두 번째 jointplot 같은 요령으로 두 번째 분포도 도시합니다. 첫 번째 jointplot에서 x 변수만 바꿔주면 됩니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights)### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3])# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4])# 3.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4])# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel(&#x27;&#x27;)axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)fig.tight_layout() 2.3.5. 부대효과 조정 : spines, grids, 간격 데이터는 모두 올라갔으니 부대 효과를 조정합니다. 불필요한 요소(ex. spines)는 제거하고, 애매한 요소(ex. 위치)는 grid로 명확히 합니다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576fig = plt.figure(figsize=(12,7))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights, wspace=0.03, hspace=0.03) # setting spaces### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3], zorder=1)# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3], zorder=2)# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False, zorder=1)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False, zorder=1)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 4.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4], zorder=1)# 4.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4], zorder=2)# 4.3. histogram (flipper_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False, zorder=1)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel(&#x27;&#x27;)axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)### 5. unnecessary elements removal# 5.1. upper-right axesaxs[2].axis(&quot;off&quot;)# 5.2. margin kdeplot scale unificationhist_range_max = max(axs[0].get_ylim()[-1], axs[1].get_ylim()[-1], axs[5].get_xlim()[-1])for i in range(len(widths)-1): axs[i].set_ylim(0, hist_range_max)axs[5].set_xlim(0, hist_range_max)# 5.3. redundent labels and titles removalaxs[1].set_yticklabels([])axs[1].set_ylabel(&#x27;&#x27;)axs[4].set_yticklabels([])axs[4].set_ylabel(&#x27;&#x27;)# 5.4. gridsfor i in range(len(heights)*len(widths)): axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0)fig.tight_layout() 1차원 분포의 스케일도 맞춰주었습니다. 그러나 꼭 필요한 작업인지는 의구심이 듭니다. ‘밀도’라는 정의에 맞게 넓이를 1로 만드는 과정이 포함되어 있는데, 이로 인해 x축 스케일이 크면 높이가 낮아지는 경향이 있기 때문입니다. 데이터의 범위에 집중하고 싶다면 스케일을 맞추지 않는 것이 나을지도 모릅니다. 2.3.6. 마무리 작업seaborn tutorial: controlling figure aesthetics 데이터를 표현하는 작업은 사실상 완료되었습니다. 폰트의 크기, 색상 등 가독성을 높입니다. 이 때도 seaborn의 set_style()과 set_context()를 사용하면 편리합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788sns.set_style(&quot;white&quot;)sns.set_context(&quot;talk&quot;)fig = plt.figure(figsize=(14,8))widths = [4, 4, 1]heights = [1, 4]### 1. gridspec preparationspec = fig.add_gridspec(ncols=3, nrows=2, width_ratios=widths, height_ratios=heights, wspace=0.03, hspace=0.03) # setting spaces### 2. setting axesaxs = &#123;&#125;for i in range(len(heights)*len(widths)): axs[i] = fig.add_subplot(spec[i//len(widths), i%len(widths)])### 3. bill_length_mm vs bill_depth_mm# 3.1. kdeplotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[3], zorder=1, legend=False)# 3.2. scatterplotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[3], zorder=2, legend=False)# 3.3. histogram (bill_length_mm)sns.kdeplot(&quot;bill_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[0], legend=False, zorder=1, fill=True)axs[0].set_xlim(axs[3].get_xlim())axs[0].set_xlabel(&#x27;&#x27;)axs[0].set_xticklabels([])axs[0].spines[&quot;left&quot;].set_visible(False)axs[0].spines[&quot;top&quot;].set_visible(False)axs[0].spines[&quot;right&quot;].set_visible(False)# 3.3. histogram (bill_depth_mm)sns.kdeplot(y=&quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[5], legend=False, zorder=1, fill=True)axs[5].set_ylim(axs[3].get_ylim())axs[5].set_ylabel(&#x27;&#x27;)axs[5].set_yticklabels([])axs[5].spines[&quot;bottom&quot;].set_visible(False)axs[5].spines[&quot;top&quot;].set_visible(False)axs[5].spines[&quot;right&quot;].set_visible(False)### 4. flipper_length_mm vs bill_depth_mm# 4.1. kdeplotsns.kdeplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, alpha=0.3, ax=axs[4], zorder=1)# 4.2. scatterplotsns.scatterplot(&quot;flipper_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[4], zorder=2)# 4.3. histogram (flipper_length_mm)sns.kdeplot(&quot;flipper_length_mm&quot;, data=penguins, hue=&quot;species&quot;, ax=axs[1], legend=False, zorder=1, fill=True)axs[1].set_xlim(axs[4].get_xlim())axs[1].set_xlabel(&#x27;&#x27;)axs[1].set_xticklabels([])axs[1].spines[&quot;left&quot;].set_visible(False)axs[1].spines[&quot;top&quot;].set_visible(False)axs[1].spines[&quot;right&quot;].set_visible(False)### 5. unnecessary elements removal# 5.1. upper-right axesaxs[2].axis(&quot;off&quot;)# 5.2. margin kdeplot scale unificationhist_range_max = max(axs[0].get_ylim()[-1], axs[1].get_ylim()[-1], axs[5].get_xlim()[-1])for i in range(len(widths)-1): axs[i].set_ylim(0, hist_range_max)axs[5].set_xlim(0, hist_range_max)# 5.3. redundent labels and titles removalaxs[1].set_yticklabels([])axs[1].set_ylabel(&#x27;&#x27;)axs[4].set_yticklabels([])axs[4].set_ylabel(&#x27;&#x27;)# 5.4. gridsfor i in range(len(heights)*len(widths)): axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) # 5.5. labelsfont_label = &#123;&quot;color&quot;:&quot;gray&quot;&#125;axs[3].set_xlabel(&quot;Bill Legnth (mm)&quot;, fontdict=font_label, labelpad=12)axs[3].set_ylabel(&quot;Bill Depth (mm)&quot;, fontdict=font_label, labelpad=12)axs[4].set_xlabel(&quot;Flipper Legnth (mm)&quot;, fontdict=font_label, labelpad=12)axs[0].set_ylabel(&quot;Density&quot;, fontdict=font_label, labelpad=12)axs[5].set_xlabel(&quot;Density&quot;, fontdict=font_label, labelpad=12)fig.tight_layout() jointplot의 한계인 2중 jointplot이 구현되었습니다. 2.3.7. generalize : 함수로 만들기 하는 김에, 기능을 일반화합시다. 다중 jointplot 제작 기능을 함수로 만들고, x 변수의 수와 그림 크기, 1차원 분포 스케일 통일 등을 인자로 만듭니다 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163def jointplots(xs, y, data, hue=None, height=6, ratio=5, space=0.2, xlabels=None, ylabel=None, margin_norm=False): &quot;&quot;&quot; ------------------- Input Parameters ------------------- xs : (list or str) feature name(s) of data y : (str) feature name of data data : (pandas.DataFrame) hue : (str) semantic variable that is mapped to determine the color of plot elements. Semantic variable that is mapped to determine the color of plot elements. height : (float) size of the figure ratio : (float) ratio of the joint axes height to marginal axes height. space : (float) space between the joint and marginal axes xlabels : (list or str) xlabels ylabel : (str) ylabel margin_norm : (boolean) if True, kdeplots at marginal axes have same scale. &quot;&quot;&quot; ### 1. input check # input type assert isinstance(xs, list) or isinstance(xs, str) if isinstance(xs, list): assert all([isinstance(x, str) for x in xs]) else: xs = [xs] if xlabels != None: assert isinstance(xlabels, list) or isinstance(xlabels, str) if isinstance(xlabels, list): assert all([isinstance(xlabel, str) for xlabel in xlabels]) else: xlabels = [xlabels] if ylabel != None: assert isinstance(ylabel, str) if hue != None: assert isinstance(hue, str) # input data assert all([x in data.columns for x in xs]) assert y in data.columns if hue != None: assert hue in data.columns ### 2. figure h_margin = height / (ratio + 1) h_joint = height - h_margin if isinstance(xs, list): n_x = len(xs) else: n_x = 1 widths = [h_joint] * n_x + [h_margin] heights = [h_margin, h_joint] ncols = len(widths) nrows = len(heights) fig = plt.figure(figsize=(sum(widths), sum(heights))) ### 3. gridspec preparation spec = fig.add_gridspec(ncols=ncols, nrows=nrows, width_ratios = widths, height_ratios = heights, wspace=space, hspace=space ) ### 4. setting axes axs = &#123;&#125; for i in range(ncols * nrows): axs[i] = fig.add_subplot(spec[i//ncols, i%ncols]) ### 5. jointplots (scatterplot + kdeplot) for i, x in enumerate(xs, ncols): if i == ncols: legend=True else: legend=False sns.kdeplot(x=x, y=y, data=data, hue=hue, alpha=0.3, ax=axs[i], zorder=2, legend=False) sns.scatterplot(x=x, y=y, data=data, hue=hue, alpha=0.8, ax=axs[i], zorder=3, legend=legend) ### 6. kdeplots at marginal axes axs[ncols-1].axis(&quot;off&quot;) axes_mx = list(range(ncols-1)) axes_my = 2*ncols - 1 for i, x in zip(axes_mx, xs): sns.kdeplot(x=x, data=data, hue=hue, fill=True, ax=axs[i], zorder=2, legend=False) axs[i].set_xlim(axs[i+ncols].get_xlim()) axs[i].set_xlabel(&quot;&quot;) axs[i].set_xticklabels([]) axs[i].spines[&quot;left&quot;].set_visible(False) axs[i].spines[&quot;top&quot;].set_visible(False) axs[i].spines[&quot;right&quot;].set_visible(False) sns.kdeplot(y=y, data=data, hue=hue, fill=True, ax=axs[axes_my], zorder=2, legend=False) axs[axes_my].set_ylim(axs[ncols].get_ylim()) axs[axes_my].set_ylabel(&quot;&quot;) axs[axes_my].set_yticklabels([]) axs[axes_my].spines[&quot;bottom&quot;].set_visible(False) axs[axes_my].spines[&quot;top&quot;].set_visible(False) axs[axes_my].spines[&quot;right&quot;].set_visible(False) if margin_norm == True: hist_range_max = max([axs[m].get_ylim()[-1] for m in axes_mx] + [axs[axes_my].get_xlim()[-1]]) for i in axes_mx: axs[i].set_ylim(0, hist_range_max) axs[axes_my].set_xlim(0, hist_range_max) ### 7. unnecessary elements removal # 7.1. labels and ticklabels axes_j = list(range(ncols, 2*ncols-1)) for i in axes_j: if i != ncols: axs[i].set_ylabel(&quot;&quot;) axs[i].set_yticklabels([]) # 7.2. marginal axes for i in axes_mx: if i != 0: axs[i].set_ylabel(&quot;&quot;) axs[i].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) axs[i].set_yticklabels([]) yticks = axs[i].get_yticks() ylim = axs[i].get_ylim() for ytick in yticks: if 0 &lt; ytick &lt; ylim[-1]: axs[i].text(axs[i].get_xlim()[0], ytick, str(ytick), fontdict=&#123;&quot;verticalalignment&quot;:&quot;center&quot;&#125;) axs[axes_my].grid(&quot;on&quot;, color=&quot;lightgray&quot;, zorder=0) axs[axes_my].set_xticklabels([]) axes_my_xticks = axs[axes_my].get_xticks() axes_my_xlim = axs[axes_my].get_xlim() for xtick in axes_my_xticks: if 0 &lt; xtick &lt; axes_my_xlim[-1]: axs[axes_my].text(xtick, axs[axes_my].get_ylim()[0], str(xtick), rotation=270, fontdict=&#123;&quot;horizontalalignment&quot;:&quot;center&quot;&#125;) # 7.3. labels font_label = &#123;&quot;color&quot;: &quot;gray&quot;, &quot;fontsize&quot;:&quot;large&quot;&#125; labelpad = 12 for i, x in zip(axes_j, xlabels): axs[i].set_xlabel(x, fontdict=font_label, labelpad=labelpad) if i == ncols: axs[i].set_ylabel(ylabel, fontdict=font_label, labelpad=labelpad) axs[0].set_ylabel(&quot;Density&quot;, fontdict=font_label, labelpad=labelpad) axs[2*ncols-1].set_xlabel(&quot;Density&quot;, fontdict=font_label, labelpad=labelpad) fig.align_ylabels([axs[0], axs[ncols]]) fig.align_xlabels([axs[x] for x in range(ncols, 2*ncols)]) plt.tight_layout() return fig, axs X인자의 수가 바뀌어도 jointplot이 안정적으로 그려집니다. 1차원 분포도 표현 방식을 바꾸어 전보다 깔끔해졌습니다. 123jointplots([&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, &quot;flipper_length_mm&quot;], &quot;body_mass_g&quot;, penguins, hue=&quot;species&quot;, height=8, ratio=5, space=0.03, xlabels=[&quot;Bill Length (mm)&quot;, &quot;Bill Depth (mm)&quot;, &quot;Flipper Length (mm)&quot;], ylabel=&quot;Body Mass (g)&quot;) 2.4. 결론 seaborn의 jointplot을 가져다 쓰는 데 그치지 않았습니다. matplotlib의 객체지향 방식을 이용해 seaborn의 한계를 벗어날 수 있었습니다. 본 예제에서는 scatterplot과 2차원 kdeplot만 결합했습니다. 그러나 이 외에도 seaborn과 matplotlib이 제공하는 거의 모든 기능을 결합할 수 있습니다. 매뉴얼의 한계에 얽매이지 말고 상상력을 동원해 보시면 어떨까요. 출저: https://jehyunlee.github.io/2020/10/03/Python-DS-35-seaborn_matplotlib2/","categories":[],"tags":[]},{"title":"Seaborn with Matplotlib (1)","slug":"Seaborn_with_Matplotlib_1","date":"2020-11-02T05:41:57.603Z","updated":"2020-11-02T06:26:22.434Z","comments":true,"path":"2020/11/02/Seaborn_with_Matplotlib_1/","link":"","permalink":"https://kdmid.github.io/2020/11/02/Seaborn_with_Matplotlib_1/","excerpt":"","text":"1. seaborn + matplotlib seaborn을 matplotlib과 섞어쓰는 방법입니다. 4부 중 첫 번째 시간입니다. seaborn 함수 중 matplotlib axes를 반환하는 함수들에 관한 내용입니다. seaborn API seaborn은 matplotlib을 쉽고 아름답게 쓰고자 만들어졌습니다. 따라서 seaborn의 결과물은 당연히 matplotlib의 결과물입니다. 그러나 간혹 seaborn이 그린 그림의 폰트, 색상에 접근이 되지 않아 난처합니다. seaborn의 구조를 잘 이해하지 못하면 해결도 어렵습니다. v0.11 기준으로 seaborn에는 다음 함수들이 있습니다. matplotlib의 출력물은 figure와 axes만을 반환합니다. seaborn의 명령어 중 axes를 반환하는 것들은 matplotlib과 섞어 쓰기 좋습니다. 먼저 matplotlib의 객체 지향object oriented interface를 사용해서 그림의 틀을 만든 뒤, 특정 axes에 seaborn을 삽입하면 됩니다. 결론적으로, 하고 싶은 거 다 됩니다. 1.1. Load data 예제로 사용할 펭귄 데이터를 불러옵니다. seaborn에 내장되어 있습니다.123456import pandas as pdimport matplotlib.pyplot as pltimport seaborn as snspenguins = sns.load_dataset(&quot;penguins&quot;)penguins.head() 1.2. figure and axes matplotlib으로 도화지figure를 깔고 축공간axes를 만듭니다. 1 x 2 축공간을 구성합니다. 123fig, axes = plt.subplots(ncols=2, figsize=(8,4))fig.tight_layout() 1.3. plot with matplotlib matplotlib 기능을 이용해서 산점도를 그립니다. x축은 부리 길이 bill length y축은 부리 위 아래 두께 bill depth 색상은 종species로 합니다. Adelie, Chinstrap, Gentoo이 있습니다. 두 축공간 중 왼쪽에만 그립니다. 123456789101112131415fig, axes = plt.subplots(ncols=2, figsize=(8, 4))species_u = penguins[&quot;species&quot;].unique()# plot 0 : matplotlibfor i, s in enumerate(species_u): axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C&#123;i&#125;&quot;, label=s, alpha=0.3 )axes[0].legend(species_u, title=&quot;species&quot;)axes[0].set_xlabel(&quot;Bill Length (mm)&quot;)axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;)fig.tight_layout() 1.4. plot with seabornseaborn scatterplot 이번엔 같은 plot을 seaborn으로 그려봅니다. 위 코드에 아래 세 줄만 추가합니다. 1234# plot 1 : seabornsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1])axes[1].set_xlabel(&quot;Bill Length (mm)&quot;)axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;) 세 줄로 거의 동일한 그림이 나왔습니다. scatter plot의 점 크기만 살짝 작습니다. label의 투명도만 살짝 다릅니다. seaborn 명령 scatterplot()을 그대로 사용했습니다. x축과 y축 label도 바꾸었습니다. ax=axes[1] 인자에서 볼 수 있듯, 존재하는 axes에 그림만 얹었습니다. matplotlib 틀 + seaborn 그림 이므로, matplotlib 명령이 모두 통합니다. 1.5. matplotlib + seaborn &amp; seaborn + matplotlib matplotlib과 seaborn이 자유롭게 섞일 수 있습니다. matplotlib 산점도 위에 seaborn 추세선을 얹을 수 있고, seaborn 산점도 위에 matplotlib 중심점을 얹을 수 있습니다. 파이썬 코드는 다음과 같습니다. 12345678910111213141516171819202122232425262728293031323334fig, axes = plt.subplots(ncols=2, figsize=(8, 4))species_u = penguins[&quot;species&quot;].unique()# plot 0 : matplotlib + seabornfor i, s in enumerate(species_u): # matplotlib 산점도 axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C&#123;i&#125;&quot;, label=s, alpha=0.3 ) # seaborn 추세선 sns.regplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, data=penguins.loc[penguins[&quot;species&quot;]==s], scatter=False, ax=axes[0]) axes[0].legend(species_u, title=&quot;species&quot;)axes[0].set_xlabel(&quot;Bill Length (mm)&quot;)axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;)# plot 1 : seaborn + matplotlib# seaborn 산점도sns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1])axes[1].set_xlabel(&quot;Bill Length (mm)&quot;)axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;)for i, s in enumerate(species_u): # matplotlib 중심점 axes[1].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), c=f&quot;C&#123;i&#125;&quot;, alpha=1, marker=&quot;x&quot;, s=100 )fig.tight_layout() 1.6. seaborn + seaborn + matplotlib 안 될 이유가 없습니다. seaborn scatterplot + seaborn kdeplot + matplotlib text입니다. 1234567891011121314151617181920fig, ax = plt.subplots(figsize=(6,5))# plot 0: scatter plotsns.scatterplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, color=&quot;k&quot;, data=penguins, alpha=0.3, ax=ax, legend=False)# plot 1: kde plotsns.kdeplot(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.5, ax=ax, legend=False)# text:species_u = penguins[&quot;species&quot;].unique()for i, s in enumerate(species_u): ax.text(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), s = s, fontdict=&#123;&quot;fontsize&quot;:14, &quot;fontweight&quot;:&quot;bold&quot;,&quot;color&quot;:&quot;k&quot;&#125; )ax.set_xlabel(&quot;Bill Length (mm)&quot;)ax.set_ylabel(&quot;Bill Depth (mm)&quot;)fig.tight_layout() 1.7. 결론 seaborn을 matplotlib과 마음껏 섞어쓰세요 단, axes를 반환하는 명령어에 한해서 말입니다. 이런 명령어를 axes-level function 이라고 합니다. 출저: https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/","categories":[],"tags":[]},{"title":"","slug":"hello-world","date":"2020-10-30T02:32:48.799Z","updated":"2020-10-30T02:32:48.887Z","comments":true,"path":"2020/10/30/hello-world/","link":"","permalink":"https://kdmid.github.io/2020/10/30/hello-world/","excerpt":"","text":"SQL SELECT 함수 /*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=\"1.11.3\",m=function(a,b){return new m.fn.init(a,b)},n=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,o=/^-ms-/,p=/-([\\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:\"jQuery\"+(l+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===m.type(a)},isArray:Array.isArray||function(a){return\"array\"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,\"constructor\")&&!j.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,\"ms-\").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(n,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function r(a){var b=\"length\"in a&&a.length,c=m.type(a);return\"function\"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1","categories":[],"tags":[]},{"title":"","slug":"text","date":"2020-10-28T14:00:42.566Z","updated":"2020-10-28T14:00:42.616Z","comments":true,"path":"2020/10/28/text/","link":"","permalink":"https://kdmid.github.io/2020/10/28/text/","excerpt":"","text":"text /*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=\"1.11.3\",m=function(a,b){return new m.fn.init(a,b)},n=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,o=/^-ms-/,p=/-([\\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:\"jQuery\"+(l+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===m.type(a)},isArray:Array.isArray||function(a){return\"array\"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,\"constructor\")&&!j.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,\"ms-\").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(n,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function r(a){var b=\"length\"in a&&a.length,c=m.type(a);return\"function\"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1","categories":[],"tags":[]},{"title":"SELECT와 WHERE 함수","slug":"hello-world","date":"2020-10-28T13:38:14.448Z","updated":"2020-10-30T04:10:43.474Z","comments":true,"path":"2020/10/28/hello-world/","link":"","permalink":"https://kdmid.github.io/2020/10/28/hello-world/","excerpt":"","text":"SELECT로 테이블 전체 불러오기 SELECT 명력은 “SELECT 필드명 FROM 테이블명” 형식으로 필드 전체나 일부를 검색한다. SELECT * FROM 테이블명; 12SELECT *FROM tb_customer; SELECT로 원하는 필드값만 불러오기SELECT 필드명1, 필드명2 ··· , 필드명n FROM 테이블명; 12345SELECT customer_cd,customer_nm,phone_number,emailFROM TB_CUSTOMER; SELECT로 필드명 수정하기SELECT 필드명 [AS] 별명 FROM 테이블명; 별명을 지정하는 ‘AS’는 생략할 수 있다. 기본적으로 별명은 숫자가 아닌 문자로 시작해야한다. 숫자로 시작하는 별명이나 중간에 공백이 있는 별명을 사용하려면 따옴표(“”) 안에 별명을 넣어준다. 12345SELECT customer_cd AS 고객코드,customer_nm AS 고객명,phone_number AS 전화번호,email AS 이메일FROM tb_customer; WHERE로 조건에 맞는 데이터 불러오기 형식123SELECT 검색필드명FROM 테이블명WHERE 조건식; 123SELECT *FROM tb_customerWHERE mw_flg = &#x27;M&#x27;; BETWEEN ..AND 함수로 지정범위 데이터 검색","categories":[],"tags":[]}],"categories":[],"tags":[]}